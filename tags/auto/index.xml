<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>auto | EvaNote</title>
    <link>https://evandde.github.io/tags/auto/</link>
      <atom:link href="https://evandde.github.io/tags/auto/index.xml" rel="self" type="application/rss+xml" />
    <description>auto</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>ko-kr</language><copyright>© 2020–2022 Evan Kim</copyright><lastBuildDate>Sat, 19 Mar 2022 20:22:14 +0900</lastBuildDate>
    <image>
      <url>https://evandde.github.io/media/icon_hu8e7e87b14a52eedd9109bf1b224bd29e_18847_512x512_fill_lanczos_center_3.png</url>
      <title>auto</title>
      <link>https://evandde.github.io/tags/auto/</link>
    </image>
    
    <item>
      <title>대충보는 C&#43;&#43; &amp; CMake - 9. 변수와 auto</title>
      <link>https://evandde.github.io/praccpp-009-variable/</link>
      <pubDate>Sat, 19 Mar 2022 20:22:14 +0900</pubDate>
      <guid>https://evandde.github.io/praccpp-009-variable/</guid>
      <description>&lt;p&gt;이 글에서는 C++에서 &lt;strong&gt;변수를 선언하는 법&lt;/strong&gt;과 &lt;strong&gt;그 변수에 값을 저장&lt;/strong&gt;하는 법을 알아봅니다.&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++에서는 문장을 쓰고 마침표의 의미로 세미콜론(&lt;code&gt;;&lt;/code&gt;)을 씀&lt;/li&gt;
&lt;li&gt;&lt;code&gt;자료형 변수명;&lt;/code&gt; (e.g. &lt;code&gt;int num;&lt;/code&gt;) 이라고 작성하여 메모리 공간 중 일부에 &lt;code&gt;변수명&lt;/code&gt;이라는 이름을 붙여 활용할 수 있으며, &lt;code&gt;=&lt;/code&gt; 연산자를 활용하여 그 공간에 값을 저장할 수도 있음&lt;/li&gt;
&lt;li&gt;자료형을 적어야 할 때 &lt;strong&gt;그 데이터의 자료형을 컴파일러가 결정할 수 있는 상태&lt;/strong&gt;라면 자료형을 굳이 직접 쓰지 않아도 &lt;code&gt;auto&lt;/code&gt;라는 키워드를 통해 컴파일러에게 자료형 결정을 떠넘길 수 있음 (e.g. &lt;code&gt;auto num = 3;&lt;/code&gt;이라고 쓰면 컴파일러가 &lt;code&gt;auto&lt;/code&gt; 부분을 알아서 &lt;code&gt;int&lt;/code&gt;로 인식함)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;세미콜론&#34;&gt;세미콜론(&lt;code&gt;;&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;우리말은 문장이 끝났다는 의미로 마침표(&#39;.&#39;)를 적습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++에서도 컴파일러에게 한 문장이 끝났다는 것을 명시&lt;/strong&gt;해주어야 합니다. 이 때 마침표의 의미로 사용하는 기호가 &lt;b&gt;세미콜론(&lt;code&gt;;&lt;/code&gt;)&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p&gt;너무나 당연하게 자주 사용하고 보게 될 기호입니다만, 따로 강의글까지 만들 정도의 내용은 아닌 것 같아, 여기서 간단하게 설명하고 넘어갑니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;변수&#34;&gt;변수&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;변수&lt;/strong&gt;란 간단히 말해 &lt;strong&gt;자유로운 데이터 저장소&lt;/strong&gt;입니다. 제한조건은 단 한 가지, &lt;strong&gt;미리 그 저장소의 자료형을 정해두어야 한다는 것&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h3 id=&#34;변수의-선언declaration&#34;&gt;변수의 선언(declaration)&lt;/h3&gt;
&lt;p&gt;변수의 선언이란, C++ 프로그램에서 &lt;strong&gt;이 변수를 사용하겠다&lt;/strong&gt;라고 선언하는 것을 뜻합니다. 코드로는 &lt;code&gt;자료형 변수명;&lt;/code&gt;과 같이 적습니다.&lt;/p&gt;
&lt;p&gt;변수명으로는 알파벳 대소문자(&lt;code&gt;A~Z&lt;/code&gt;, &lt;code&gt;a~z&lt;/code&gt;), 숫자(&lt;code&gt;0~9&lt;/code&gt;), 언더바(&lt;code&gt;_&lt;/code&gt;)를 자유롭게 조합하여 사용할 수 있습니다. (일부 C++에서 사용하는 문구는 불가능한 경우도 있습니다.)&lt;/p&gt;
&lt;p&gt;예시를 보자면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int num; // Declare an int-type variable named &amp;quot;num&amp;quot;
double dbl_val; // Declare a double-type variable named &amp;quot;dbl_val&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;값의-저장과-사용&#34;&gt;값의 저장과 사용&lt;/h3&gt;
&lt;p&gt;변수를 만들어두었다면, 이 변수에 임의의 값을 저장해 둘 수 있습니다. 저장할 때에는 &lt;code&gt;변수명 = 저장할값;&lt;/code&gt;과 같이 적습니다. &lt;code&gt;=&lt;/code&gt; 기호는 같다는 의미의 연산자가 아니라 &lt;b&gt;우측의 값을 좌측의 메모리공간에 대입하는 연산자&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p&gt;만약, 변수를 선언함과 동시에 값의 저장까지 하고 싶다면, &lt;code&gt;자료형 변수명 = 저장할값;&lt;/code&gt;과 같이 한 데 묶어서 적을 수도 있습니다&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;이 때, &lt;font color=red&gt;&lt;b&gt;변수의 자료형과 저장할 값의 자료형은 동일해야 합니다&lt;/b&gt;&lt;/font&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;값이 저장되어 있다면, 이후에는 &lt;code&gt;변수명&lt;/code&gt;을 이용하여 그 값이 필요한 곳에서 자유롭게 호출하여 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;저장된 값을 변경하려면 &lt;code&gt;변수명 = 저장할값;&lt;/code&gt;을 한 번 더 쓰면 됩니다.&lt;/p&gt;
&lt;p&gt;예시를 보자면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int num = 3; // The value &amp;quot;3&amp;quot; was stored in a variable named &amp;quot;num&amp;quot;
std::cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl; // This will print 3
num = 5; // The value of variable named &amp;quot;num&amp;quot; has been changed to &amp;quot;5&amp;quot;
std::cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl; // This will print 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;auto-키워드&#34;&gt;auto 키워드&lt;/h2&gt;
&lt;p&gt;자료형을 적어야 할 때, &lt;b&gt;그 자리에 무슨 자료형이 적혀야 하는지가 명확하다면&lt;/b&gt;, 자료형을 직접 적지않고 컴파일러가 알아서 결정하게끔 할 수 있습니다. 이 때 활용하는 키워드가 &lt;code&gt;auto&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code&gt;int num = -1;&lt;/code&gt; 이라는 문장을 생각해봅시다. 여기서 &lt;code&gt;int&lt;/code&gt; 자리에 굳이 &lt;code&gt;int&lt;/code&gt;라는 자료형을 명시해주지 않더라도, &lt;code&gt;num&lt;/code&gt;이라는 변수가 &lt;code&gt;-1&lt;/code&gt;이라는 값을 저장해야 한다는 사실로부터 &lt;code&gt;num&lt;/code&gt;의 자료형이 &lt;code&gt;int&lt;/code&gt;가 되어야 한다고 판단할 수 있겠지요&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. 이런 경우에는 &lt;code&gt;int&lt;/code&gt; 대신 &lt;code&gt;auto&lt;/code&gt;를 적을 수 있습니다. 다음과 같이 말이지요.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto num = -1; // int num = -1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;단, 컴파일러가 자료형을 결정할 수 없는 경우에는 &lt;code&gt;auto&lt;/code&gt; 키워드를 사용할 수 없습니다. 예를 들어 &lt;code&gt;auto num;&lt;/code&gt;과 같이 값을 저장하지 않고 선언만 하는 경우에는, &lt;code&gt;num&lt;/code&gt;이 어떤 자료형을 가져야 하는지 판단할 수 없으므로 &lt;font color=red&gt;컴파일 에러가 발생&lt;/font&gt;합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chanagelog&#34;&gt;Chanagelog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2022-03-19: 최초 게시&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;좀 더 정교한 설명을 위해서는, 선언(declare)/정의(define)/초기화(initialize)/할당(assign) 등으로 용어를 좀 더 세분화하여 이해할 필요도 있겠으나, 여기서는 간단하게만 설명하고 넘어가겠습니다. 필요한 분은 위의 키워드를 검색하여 공부해보시기 바랍니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;엄밀히 말하면 동일하지는 않아도 됩니다만, 저장할 값의 자료형으로부터 변수의 자료형으로 자동 형변환이 이루어질 수 있어야 합니다. 예를 들어, 3.0이라는 실수 자료형은 C++에서 자동적으로 3이라는 정수 자료형으로 형변환이 가능합니다. 이 경우에는 &lt;code&gt;int num = 3.0;&lt;/code&gt;과 같이 적어도 에러가 발생하지는 않습니다(warning은 발생할 수도 있습니다).&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;경우에 따라 가능한 자료형이 여러 가지인 경우도 있습니다. 이런 경우에는 &lt;code&gt;auto&lt;/code&gt; 키워드를 어떤 자료형으로 인식할 것인지 컴파일러가 가진 나름의 규칙을 바탕으로 결정합니다.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
  </channel>
</rss>
