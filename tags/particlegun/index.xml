<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ParticleGun | EvaNote</title>
    <link>https://evandde.github.io/tags/particlegun/</link>
      <atom:link href="https://evandde.github.io/tags/particlegun/index.xml" rel="self" type="application/rss+xml" />
    <description>ParticleGun</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>ko-kr</language><copyright>© 2020–2021 Evan Kim</copyright><lastBuildDate>Thu, 25 Nov 2021 16:03:52 +0900</lastBuildDate>
    <image>
      <url>https://evandde.github.io/media/icon_hu8e7e87b14a52eedd9109bf1b224bd29e_18847_512x512_fill_lanczos_center_3.png</url>
      <title>ParticleGun</title>
      <link>https://evandde.github.io/tags/particlegun/</link>
    </image>
    
    <item>
      <title>Geant4용 개선된 ParticleGun 클래스(지오메트리 선원항/타겟 설정, 동위원소 모델링)</title>
      <link>https://evandde.github.io/advancedparticlegun/</link>
      <pubDate>Thu, 25 Nov 2021 16:03:52 +0900</pubDate>
      <guid>https://evandde.github.io/advancedparticlegun/</guid>
      <description>&lt;p&gt;Geant4에서 기본 제공하는 G4ParticleGun 클래스보다 좀 더 많은 기능이 필요해서 제가 직접 만들어 쓰고 있는 &lt;b&gt;AdvancedParticleGun 클래스&lt;/b&gt;를 소개합니다. &lt;b&gt;특정 지오메트리를 선원항으로 사용&lt;/b&gt;하려는 경우, &lt;b&gt;특정 지오메트리 방향으로만 방사선을 방출&lt;/b&gt;시키고자 하는 경우, &lt;b&gt;방사성동위원소&lt;/b&gt;를 선원으로 두려고 하는 경우에 유용하게 사용할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;h3 id=&#34;용도&#34;&gt;용도&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;00_advpg&#34;
           src=&#34;https://evandde.github.io/advancedparticlegun/00_advpg.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이미 모사해 둔 &lt;b&gt;지오메트리 중 하나를 선원항으로 지정&lt;/b&gt;하고 싶을 때&lt;/li&gt;
&lt;li&gt;방사선이 방출되는 &lt;b&gt;방향을 특정 지오메트리 쪽으로 제한&lt;/b&gt;하고 싶을 때&lt;/li&gt;
&lt;li&gt;방사성동위원소가 방출하는 &lt;b&gt;감마선 및 엑스선&lt;/b&gt;만을 선원항으로 두고 싶을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다운로드-경로&#34;&gt;다운로드 경로&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;필요한 항목만 압축한 파일: &lt;a href=&#34;https://evandde.github.io/uploads/advpg.zip&#34; target=&#34;_blank&#34;&gt;advpg.zip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;예제가 담긴 GitHub repository: &lt;a href=&#34;https://github.com/evandde/example_advpg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;evandde/example_advpg: Example of Advanced Particle Gun class for Geant4. (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;예제 압축파일 다운 링크(GitHub repository에서 받는 것과 동일): &lt;a href=&#34;https://github.com/evandde/example_advpg/archive/refs/heads/main.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example_advpg.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;사용방법&#34;&gt;사용방법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;위에서 advpg.zip을 다운받아, 압축을 풀어서 나오는 3개 폴더(ICRP07DATA, include, src)를 프로젝트에 붙여넣기 (Geant4의 일반적인 디렉토리 구성을 따른다고 가정)&lt;/li&gt;
&lt;li&gt;사용자의 PrimaryGeneratorAction에서, ParticleGun 대신 AdvancedParticleGun 객체를 만들어서 사용&lt;/li&gt;
&lt;li&gt;기존 ParticleGun의 기능은 그대로 사용 가능&lt;/li&gt;
&lt;li&gt;추가적으로 다음의 멤버함수를 사용 가능
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void SetNuclideSource(G4String nuclideName)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void SetMinPhotonEnergy(G4double minPhotonEnergy)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void SetSourceVolume(G4String sourceVolName)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void SetTargetVolume(G4String targetVolName, G4double margin)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기능에 따라 초기 입자의 가중치(weight)가 조절될 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;다운로드&#34;&gt;다운로드&lt;/h2&gt;
&lt;p&gt;여러분의 Geant4 프로젝트는 다음과 같은 일반적인 디렉토리 구성을 따른다고 가정하여 진행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;projectDirectory
|- main.cc
|- include/
|  |- .hh
|  |- ...
|- src/
|  |- .cc
|  |- ...
|- CMakeLists.txt
|- .mac
|- ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일단, &lt;a href=&#34;https://evandde.github.io/uploads/advpg.zip&#34; target=&#34;_blank&#34;&gt;advpg.zip&lt;/a&gt; 파일을 다운로드 받습니다. 제공해드리는 advpg.zip 압축파일에는 다음과 같은 내용물이 들어 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ICRP07DATA/
|- ICRP-07.NDX	# ICRP107 제공; Index File
|- ICRP-07.RAD	# ICRP107 제공; Radiation File
include/
|- AdvancedParticleGun.hh
|- ICRP07Manager.hh
src/
|- AdvancedParticleGun.cc
|- ICRP07Manager.cc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 그대로 여러분의 프로젝트에 옮겨 넣으시면, &lt;code&gt;ICRP07DATA&lt;/code&gt;라는 디렉토리가 추가로 생기고, &lt;code&gt;include&lt;/code&gt;와 &lt;code&gt;src&lt;/code&gt; 디렉토리는 기존의 것과 합쳐져 &lt;code&gt;AdvancedParticleGun&lt;/code&gt;과 &lt;code&gt;ICRP07Manager&lt;/code&gt;클래스에 관한 두 개씩의 파일만 추가될 것입니다.&lt;/p&gt;
&lt;p&gt;최종적으로 여러분의 프로젝트가 다음과 같이 되어있으면 세팅은 끝입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;projectDirectory
|- main.cc
|- ICRP07DATA/
|  |- ICRP-07.NDX
|  |- ICRP-07.RAD
|- include/
|  |- AdvancedParticleGun.hh
|  |- ICRP07Manager.hh
|  |- ...
|- src/
|  |- AdvancedParticleGun.cc
|  |- ICRP07Manager.cc
|  |- ...
|- CMakeLists.txt
|- .mac
|- ...
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;클래스-설명&#34;&gt;클래스 설명&lt;/h2&gt;
&lt;h3 id=&#34;advancedparticlegun-클래스&#34;&gt;AdvancedParticleGun 클래스&lt;/h3&gt;
&lt;p&gt;AdvancedParticleGun 클래스는 Geant4에서 공식으로 제공하는 G4ParticleGun 클래스를 public으로 상속받아 만들어진 클래스입니다. 따라서 여러분이 기존에 G4ParticleGun 클래스를 사용하던 방식과 동일하게 AdvancedParticleGun 클래스를 사용하시면 됩니다. 여러분이 G4VUserPrimaryGeneratorAction 클래스를 상속받아 만든 클래스 내에서 AdvancedParticleGun 클래스의 객체를 만들고, 기존과 동일한 방법으로 GeneratePrimaryVertex() 멤버함수를 이용하여 초기 입자를 생성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;G4ParticleGun 클래스가 제공하는 다음과 같은 멤버함수도 동일하게 사용 가능합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SetParticleDefinition()&lt;/li&gt;
&lt;li&gt;SetParticleCharge()&lt;/li&gt;
&lt;li&gt;SetParticleEnergy()&lt;/li&gt;
&lt;li&gt;SetParticleMomentumDirection()&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이와 더불어, AdvancedParticleGun 클래스는 추가적으로 다음과 같은 멤버함수를 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SetSourceVolume()&lt;/li&gt;
&lt;li&gt;GetSourceVolume()&lt;/li&gt;
&lt;li&gt;SetTargetVolume()&lt;/li&gt;
&lt;li&gt;GetTargetVolume()&lt;/li&gt;
&lt;li&gt;SetTargetVolumeMargin()&lt;/li&gt;
&lt;li&gt;GetTargetVolumeMargin()&lt;/li&gt;
&lt;li&gt;SetNuclideSource()&lt;/li&gt;
&lt;li&gt;GetNuclideSource()&lt;/li&gt;
&lt;li&gt;SetMinPhotonEnergy()&lt;/li&gt;
&lt;li&gt;GetMinPhotonEnergy()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;icrp07manager-클래스&#34;&gt;ICRP07Manager 클래스&lt;/h3&gt;
&lt;p&gt;ICRP07Manager 클래스는 &lt;code&gt;ICRP07DATA&lt;/code&gt; 디렉토리 내에 존재하는 ICRP Publication 107의 데이터를 읽어오고 활용하기 위한 클래스입니다.&lt;/p&gt;
&lt;p&gt;사용자가 ICRP07Manager 클래스를 직접 핸들링할 필요는 없으며, ICRP07Manager 클래스의 기능 중 사용자가 필요한 기능은 AdvancedParticleGun 클래스를 통해 사용할 수 있도록 포장(wrapping)해 두었습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;사용방법-상세&#34;&gt;사용방법 상세&lt;/h2&gt;
&lt;h3 id=&#34;지오메트리를-선원항으로-설정&#34;&gt;지오메트리를 선원항으로 설정&lt;/h3&gt;
&lt;p&gt;사용자가 만들어 둔 &lt;b&gt;G4VPhysicalVolume 클래스의 객체 중 하나&lt;/b&gt;를 &lt;b&gt;균일하게 방사선을 방출하는 선원항으로 설정&lt;/b&gt;합니다. 이 기능을 사용하면 다음 그림과 같이 특정 지오메트리를 선원항으로 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;01_source&#34;
           src=&#34;https://evandde.github.io/advancedparticlegun/01_source.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 SetSourceVolume() 함수를 사용합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetSourceVolume(G4VPhysicalVolume *sourceVol);
void SetSourceVolume(G4String sourceVolName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자는 SetSourceVolume() 함수의 입력인자로 G4VPhysicalVolume 클래스 객체의 포인터를 직접 입력할 수 있습니다.&lt;/p&gt;
&lt;p&gt;혹은, 해당 객체의 이름(Geant4 내에서 명명된 G4String형 이름)이 유일하다면, 포인터 대신 이름만 입력할 수도 있습니다. 이 경우에는 G4PhysicalVolumeStore 클래스를 활용하여, 해당 이름을 갖는 G4VPhysicalVolume 클래스의 객체를 자동으로 찾아옵니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    G4PhysicalVolumeStore 클래스의 특성 상, 이름이 중복되는 경우에는 그 중 먼저 검색된 하나의 객체만을 반환합니다. 이 경우, 의도와 달리 동작할 수 있습니다.
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;선원항으로 사용할 G4VPhysicalVolume 클래스 객체가 선택되면, 앞으로 AdvancedParticleGun 클래스는 &lt;b&gt;선원의 위치를 해당 선원 객체 내부의 임의의 지점으로 균일하게 샘플링&lt;/b&gt;합니다. 샘플링 방식은 해당 지오메트리를 감싸는 직육면체를 상정하여 샘플링한 뒤, rejection method 기법을 활용합니다. 따라서, 지오메트리의 형태에 따라 선원의 위치를 샘플링하는 데에 소요되는 시간이 상이할 수 있습니다.&lt;/p&gt;
&lt;p&gt;만약 해당 기능을 해제하여 사용하지 않고자 하는 경우에는, SetSourceVolume() 함수의 입력인자로 &lt;code&gt;nullptr&lt;/code&gt;을 넣어주시면 됩니다.&lt;/p&gt;
&lt;p&gt;이 기능은 선원의 위치를 지정하므로, SetParticlePosition() 함수와 기능상 충돌합니다. 만약 SetSourceVolume() 함수를 통해 유효한 G4VPhysicalVolume 객체로 선원항이 설정된 상태라면, &lt;b&gt;SetParticlePosition() 함수를 무시하고 이 함수로 설정된 지오메트리를 우선&lt;/b&gt;합니다. 이를 원치 않는다면 반드시 SetSourceVolume() 함수의 기능을 해제하셔야 합니다.&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 GetSourceVolume() 함수를 사용하면, 현재 설정된 선원 지오메트리의 G4VPhysicalVolume 클래스 객체의 포인터를 확인할 수 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4VPhysicalVolume *GetSourceVolume() const;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;지오메트리를-타겟으로-설정&#34;&gt;지오메트리를 타겟으로 설정&lt;/h3&gt;
&lt;p&gt;사용자가 만들어 둔 &lt;b&gt;G4VPhysicalVolume 클래스의 객체 중 하나&lt;/b&gt;를 &lt;b&gt;방사선이 도달할 타겟으로 설정&lt;/b&gt;합니다. 이 기능을 사용하면 다음 그림과 같이 특정 지오메트리를 타겟으로 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;02_target&#34;
           src=&#34;https://evandde.github.io/advancedparticlegun/02_target.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 SetTargetVolume() 함수를 사용합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetTargetVolume(G4VPhysicalVolume *targetVol, G4double margin = 0.);
void SetTargetVolume(G4String targetVolName, G4double margin = 0.);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자는 SetTargetVolume() 함수의 입력인자로 G4VPhysicalVolume 클래스 객체의 포인터를 직접 입력할 수 있습니다.&lt;/p&gt;
&lt;p&gt;혹은, 해당 객체의 이름(Geant4 내에서 명명된 G4String형 이름)이 유일하다면, 포인터 대신 이름만 입력할 수도 있습니다. 이 경우에는 G4PhysicalVolumeStore 클래스를 활용하여, 해당 이름을 갖는 G4VPhysicalVolume 클래스의 객체를 자동으로 찾아옵니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    G4PhysicalVolumeStore 클래스의 특성 상, 이름이 중복되는 경우에는 그 중 먼저 검색된 하나의 객체만을 반환합니다. 이 경우, 의도와 달리 동작할 수 있습니다.
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;타겟으로 사용할 G4VPhysicalVolume 클래스 객체가 선택되면, 앞으로 AdvancedParticleGun 클래스는 &lt;b&gt;현재 선원의 위치로부터 해당 타겟 객체를 완전히 감싸는 원뿔 내부의 임의의 방향으로 균일하게 샘플링&lt;/b&gt;합니다. 샘플링 방식은 한 지점으로부터 isotropic한 방향을 샘플링하되 공간각을 원뿔 내부로 제한하는 방식을 사용합니다.&lt;/p&gt;
&lt;p&gt;추가적으로 SetTargetVolume() 함수는 두 번째 인자로 &lt;b&gt;길이 형태(G4double 자료형)의 &lt;code&gt;margin&lt;/code&gt; 값을 입력&lt;/b&gt;받습니다. 이는 타겟 G4VPhysicalVolume 객체를 딱 맞게 감싸는 원뿔을 기준으로, 이보다 좀 더 여유를 두어 공간각이 큰 원뿔로 방향을 설정하고자 할 때 사용합니다. 사용자는 &lt;code&gt;margin&lt;/code&gt;값을 별도로 입력하지 않아도 되며, 이 경우 &lt;b&gt;기본값은 0&lt;/b&gt;이 되어 타겟 G4VPhysicalVolume 객체를 딱 맞게 감싸는 원뿔로 방향이 설정됩니다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code&gt;margin&lt;/code&gt; 값만 바꾸고 싶은 경우에는, SetTargetVolumeMargin() 멤버함수를 사용할 수도 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetTargetVolumeMargin(G4double margin);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 해당 기능을 해제하여 사용하지 않고자 하는 경우에는, SetTargetVolume() 함수의 입력인자로 &lt;code&gt;nullptr&lt;/code&gt;을 넣어주시면 됩니다.&lt;/p&gt;
&lt;p&gt;이 기능은 선원의 위치를 지정하므로, SetParticleMomentumDirection() 함수와 기능상 충돌합니다. 만약 SetTargetVolume() 함수를 통해 유효한 G4VPhysicalVolume 객체로 선원항이 설정된 상태라면, &lt;b&gt;SetParticleMomentumDirection() 함수를 무시하고 이 함수로 설정된 지오메트리를 우선&lt;/b&gt;합니다. 이를 원치 않는다면 반드시 SetTargetVolume() 함수의 기능을 해제하셔야 합니다.&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 GetTargetVolume() 함수를 사용하면, 현재 설정된 타겟 지오메트리의 G4VPhysicalVolume 클래스 객체의 포인터를 확인할 수 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4VPhysicalVolume *GetTargetVolume() const;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더불어, GetTargetVolumeMargin() 함수를 사용하면, 현재 설정된 &lt;code&gt;margin&lt;/code&gt; 값을 확인할 수 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4double GetTargetVolumeMargin() const;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;가중치-변화&#34;&gt;가중치 변화&lt;/h4&gt;
&lt;p&gt;SetTargetVolume() 함수의 주요한 특징 중 하나는 초기입자의 가중치(weight)를 변화시킨다는 것입니다.&lt;/p&gt;
&lt;p&gt;전 방향($\Omega=4\pi$)으로의 등방적(isotropic) 방향분포가 기본이라고 보았을 때, 이 함수가 제공하는 기능은 방향분포를 일부 공간각으로 편향(bias)시키는 효과가 있습니다. 따라서, 등방적 방향분포가 제공하는 결과값과 비교하여, 변화된 공간각의 비율만큼 달라질 수 있습니다. 이를 보정하기 위해, 초기입자의 가중치를 변화시킬 필요가 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;SetTargetVolume() 함수는 이 작업을 자동으로 수행&lt;/b&gt;합니다.&lt;/p&gt;
&lt;p&gt;SetTargetVolume() 함수를 통해 결정된 원뿔의 공간각을 $\Omega$라 할 때, 초기입자의 가중치는 $\frac{\Omega}{4\pi}$배가 됩니다. 이를 통해, 공간각을 제한함으로써 결과값이 커지는 영향을 정확하게 보상해줍니다.&lt;/p&gt;
&lt;p&gt;이렇게 변화된 가중치는 G4Track 클래스의 멤버함수인 GetWeight() 함수 등을 통해 확인할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;방사성동위원소를-선원항으로-설정&#34;&gt;방사성동위원소를 선원항으로 설정&lt;/h3&gt;
&lt;p&gt;선원항의 초기입자를 &lt;b&gt;특정 방사성동위원소가 붕괴되며 방출하는 감마선 및 엑스선으로 설정&lt;/b&gt;합니다. 방사성동위원소의 핵종을 결정하면, 그 핵종이 붕괴하며 방출하는 감마선과 엑스선의 방출률(yield)을 반영하여 자동으로 초기입자가 샘플링됩니다. 붕괴된 딸핵종이 불안정한 핵종인 경우에는 딸핵종이 붕괴하며 방출하는 감마선과 엑스선도 붕괴확률 및 방출률을 반영하여 초기입자 군에 포함됩니다. 이때 붕괴도식, 붕괴확률, 방출률 등의 정보는 &lt;a href=&#34;https://www.icrp.org/publication.asp?id=ICRP%20Publication%20107&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ICRP Publication 107&lt;/a&gt;의 정보를 따릅니다.&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 SetNuclideSource() 함수를 사용합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetNuclideSource(G4String nuclideName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사용자는 SetNuclideSource() 함수의 입력인자로 G4String 형 데이터인 핵종명(&lt;code&gt;nuclideName&lt;/code&gt;)을 입력할 수 있습니다. 이 때 핵종명은 &amp;quot;Cs-137&amp;quot;, &amp;quot;Co-60&amp;quot; 등과 같이, &amp;quot;{원소기호}-{질량수}&amp;quot;의 형태로 입력해야 합니다.&lt;/p&gt;
&lt;p&gt;ICRP Publication 107에서 제공하는 데이터가 존재하는 유효한 방사성동위원소가 선택된 경우, 앞으로 AdvancedParticleGun 클래스는 &lt;b&gt;초기입자를 광자(G4Gamma)로 고정하고, 매 초기입자를 발생시킬 때마다 광자의 에너지를 붕괴도식, 붕괴확률, 방출률에 따라 샘플링&lt;/b&gt;합니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;이 기능은 모든 붕괴도식에 대해 단순히 각 딸핵종으로의 붕괴 확률만 고려합니다.&lt;/p&gt;
&lt;p&gt;반감기, 모핵종/딸핵종 간의 방사능 비율, 시간에 따른 방사능 변화 등은 반영하지 않습니다.&lt;/p&gt;
&lt;p&gt;따라서, 영년평형(secular equilibrium)을 이루지 않는 핵종의 경우에는 의도하지 않은 결과가 도출될 수 있음에 주의하시기 바랍니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;만약 해당 기능을 해제하여 사용하지 않고자 하는 경우에는, SetNuclideSource() 함수의 입력인자로 빈 스트링(&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;)을 넣어주시면 됩니다.&lt;/p&gt;
&lt;p&gt;이 기능은 선원의 입자와 에너지를 지정하므로, SetParticleDefinition() 함수 및 SetParticleEnergy() 함수와 기능상 충돌합니다. 만약 SetNuclideSource() 함수를 통해 유효한 방사성동위원소로 선원항이 설정된 상태라면, &lt;b&gt;SetParticleDefinition() 함수와 SetParticleEnergy() 함수를 무시하고 이 함수로 설정된 선원항 정보를 우선&lt;/b&gt;합니다. 이를 원치 않는다면 반드시 SetNuclideSource() 함수의 기능을 해제하셔야 합니다.&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 GetNuclideSource() 함수를 사용하면, 현재 설정된 방사성동위원소의 핵종명을 확인할 수 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4String GetNuclideSource() const;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;에너지-하한선-설정&#34;&gt;에너지 하한선 설정&lt;/h4&gt;
&lt;p&gt;추가적으로, 사용자가 저에너지 엑스선의 방출을 원하지 않는 경우에는 AdvancedParticleGun 클래스의 멤버함수인 SetMinPhotonEnergy() 함수를 통해, 발생하게 될 감마선과 엑스선의 에너지 하한선을 설정할 수 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetMinPhotonEnergy(G4double minPhotonEnergy);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 별도로 이를 설정하지 않은 경우에는 에너지 하한선(&lt;code&gt;minPhotonEnergy&lt;/code&gt;)이 0으로 설정된 것으로 간주하며, ICRP Publication 107 데이터에 제시된 모든 감마선과 엑스선이 선원항으로 설정됩니다.&lt;/p&gt;
&lt;p&gt;AdvancedParticleGun 클래스의 멤버함수인 GetMinPhotonEnergy() 함수를 사용하면, 현재 설정된 에너지 하한선의 값을 확인할 수 있습니다. 이 함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4double GetMinPhotonEnergy() const;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;가중치-변화-1&#34;&gt;가중치 변화&lt;/h4&gt;
&lt;p&gt;SetNuclideSource() 함수의 주요한 특징 중 하나는 초기입자의 가중치(weight)를 변화시킨다는 것입니다.&lt;/p&gt;
&lt;p&gt;방사성동위원소의 핵이 한 번 붕괴하는 것을 하나의 초기입자로 보았을 때, 이 함수가 제공하는 기능은 붕괴를 통해 발생되는 감마선(혹은 엑스선) 자체를 하나의 초기입자로 설정한다는 편향(bias)이 발생합니다.&lt;/p&gt;
&lt;p&gt;예를 들어, Co-60과 같이 1회의 붕괴로 1.173 MeV의 감마선과 1.332 MeV의 감마선이 각각 1.0의 Yield로 발생하는 경우를 생각해봅시다&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Co-60 핵 하나가 붕괴하였다면 하나의 초기입자로부터 감마선의 &lt;b&gt;Yield의 총 합인 2.0개 만큼&lt;/b&gt;의 감마선이 나와야 합니다. 그러나 AdvancedParticleGun 클래스의 SetNuclideSource() 함수를 사용하면, 1.173 MeV의 감마선과 1.332 MeV의 감마선 중 &lt;b&gt;한 개만 살아남아&lt;/b&gt; 초기입자가 될 것입니다. 따라서, 하나의 감마선이 &lt;b&gt;Yield의 총 합인 2.0만큼&lt;/b&gt;의 가중치(weight)를 가지고 수송이 이루어져야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;SetNuclideSource() 함수는 이에 따른 가중치 변화를 자동으로 수행&lt;/b&gt;합니다.&lt;/p&gt;
&lt;p&gt;SetNuclideSource() 함수를 통해 발생되는 초기입자는, 설정된 방사성동위원소가 방출하는 &lt;b&gt;모든 감마선과 엑스선의 방출률(Yield)의 총 합만큼 곱해진 가중치&lt;/b&gt;를 가지게 됩니다. 위에서 예로 들은 Co-60라면, 각 감마선은 원래 가중치의 두 배로 설정되는 것입니다.&lt;/p&gt;
&lt;p&gt;만약, 사용자가 SetMinPhotonEnergy() 함수를 통해 에너지 하한선을 설정하였다면, 이로 인해 &lt;b&gt;배제되는 감마선과 엑스선의 방출률은 제외&lt;/b&gt;하고 총 합을 구하게 됩니다.&lt;/p&gt;
&lt;p&gt;이렇게 변화된 가중치는 G4Track 클래스의 멤버함수인 GetWeight() 함수 등을 통해 확인할 수 있습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;license&#34;&gt;License&lt;/h2&gt;
&lt;p&gt;Copyright (C) 2021, Evan Kim (&lt;a href=&#34;mailto:evandde@gmail.com&#34;&gt;evandde@gmail.com&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;All files except &lt;code&gt;ICRP07DATA&lt;/code&gt; directory and its inside are licensed under a Creative Commons license: &lt;a href=&#34;https://creativecommons.org/licenses/by-nc-sa/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://creativecommons.org/licenses/by-nc-sa/4.0/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The files in &lt;code&gt;ICRP07DATA&lt;/code&gt; directory is from ICRP 107 copyright 2008 Eckerman and Endo. This data is provided with the following text in the license.txt file:&lt;/p&gt;
&lt;p&gt;ICRP-07 Data Files Copyright Notice&lt;/p&gt;
&lt;p&gt;Copyright (C) 2008 A. Endo and K.F. Eckerman, Authors. All Rights Reserved.&lt;/p&gt;
&lt;p&gt;Permission is hereby granted to any person obtaining a copies of the ICRP-07 data files and associated documentation to use, copy, and distribute these materials and the documentation for educational, research, and not-for-profit purposes, without fee and without a signed licensing agreement provided that the file LICENSE.TXT containing the above copyright notice, this paragraph and the following two paragraphs appears in all copies, modifications, and distributions.&lt;/p&gt;
&lt;p&gt;IN NO EVENT SHALL THE AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THE SOFTWARE, ITS DATA FILES, AND THE DOCUMENTATION.&lt;/p&gt;
&lt;p&gt;THE AUTHORS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE, DATA FILES AND ACCOMPANYING DOCUMENTATION PROVIDED HEREUNDER IS PROVIDED &amp;ldquo;AS IS&amp;rdquo;. THE AUTHORS HAVE NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, FUTURE UPDATES, ENHANCEMENTS, OR MODIFICATIONS TO THE SOFTWARE.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;계산의 편의를 위해 Yield값을 근사적으로 이용하였으며 엑스선의 방출률을 무시했습니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>Geant4 무작정 따라하기 - 8. 선원항 정의하기</title>
      <link>https://evandde.github.io/g4-noqasked-008-prigen/</link>
      <pubDate>Sun, 20 Jun 2021 21:56:43 +0900</pubDate>
      <guid>https://evandde.github.io/g4-noqasked-008-prigen/</guid>
      <description>&lt;p&gt;Geant4 무작정 따라하기 시리즈의 여덟번째. Event의 시작에 해당하는 선원항을 정의하는 방법에 대해 알아봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;코드-작성-위치&#34;&gt;코드 작성 위치&lt;/h2&gt;
&lt;p&gt;지오메트리를 정의할 때와 마찬가지로, Geant4 코드 작성 시 초기 입자에 대한 내용을 적는 곳도 정해져 있습니다.&lt;/p&gt;
&lt;p&gt;G4VUserPrimaryGeneratorAction 클래스를 상속받아 만드는 UserClass에 적어야 하며, 이 중에서도 void GeneratePrimaries(G4Event*) 함수가 매 Event마다 초기 입자를 발생시키는 역할을 담당합니다.&lt;/p&gt;
&lt;p&gt;제가 제공해드린 템플릿 코드의 &lt;strong&gt;src 디렉토리&lt;/strong&gt; 내부에 &lt;b&gt;PrimaryGeneratorAction.cc&lt;/b&gt;라는 파일이 있을 것입니다. 이 파일을 열면 다음과 같은 코드가 나옵니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;01_prigen&#34; srcset=&#34;
               /g4-noqasked-008-prigen/01_prigen_hu89531972ca7191c618249de582806470_59719_a01ed8d64ce24b9950ef18807c29c6ba.png 400w,
               /g4-noqasked-008-prigen/01_prigen_hu89531972ca7191c618249de582806470_59719_cc61a88b0145898e3d56fd6c0407394b.png 760w,
               /g4-noqasked-008-prigen/01_prigen_hu89531972ca7191c618249de582806470_59719_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/01_prigen_hu89531972ca7191c618249de582806470_59719_a01ed8d64ce24b9950ef18807c29c6ba.png&#34;
               width=&#34;760&#34;
               height=&#34;502&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;여기서 16번째 줄부터 나오는 &lt;b&gt;void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)&lt;/b&gt; 함수 안에 초기 입자에 대한 내용을 적으면 됩니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;엄밀히 말하면, Event마다 바뀌는 설정값은 이 함수 안에 적고, 바뀌지 않는 설정값은 생성자에 적는 것이 연산효율측면에서 이득이 있습니다.&lt;/p&gt;
&lt;p&gt;다만, 이 시리즈에서는 설명과 이해의 용이성을 위해 그냥 GeneratePrimaries 함수 안에 모두 작성하도록 하겠습니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;GeneratePrimaries 함수 안에는 다음과 같은 줄이 이미 작성되어 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 fPrimary 변수는 &lt;strong&gt;초기 입자에 대한 설정을 담당&lt;/strong&gt;하는 클래스인 &lt;strong&gt;G4ParticleGun&lt;/strong&gt; 클래스 객체의 포인터입니다.&lt;/p&gt;
&lt;p&gt;이 클래스는 &lt;strong&gt;GeneratePrimaryVertex라는 함수&lt;/strong&gt;를 갖고 있습니다. 이 함수는 &amp;ldquo;&lt;strong&gt;초기 입자를 발생시켜서 Event를 한 회 수행하라&lt;/strong&gt;&amp;ldquo;는 기능을 가진 함수입니다. 즉 위의 코드 한 줄에 의해 &lt;strong&gt;초기 입자가 발생&lt;/strong&gt;되는 것이지요.&lt;/p&gt;
&lt;p&gt;우리가 할 일은, &amp;ldquo;&lt;b&gt;초기 입자를 발생시키기 &lt;font color=&#39;red&#39;&gt;전&lt;/font&gt;에 초기 입자의 특성을 설정&lt;/b&gt;&amp;ldquo;하는 것입니다. 그래서, 우리가 쓸 내용은 전부 &lt;code&gt;fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);&lt;/code&gt; 줄보다 &lt;font color=&#39;red&#39;&gt;&lt;b&gt;위쪽에 위치&lt;/b&gt;&lt;/font&gt;해야 합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;g4particlegun&#34;&gt;G4ParticleGun&lt;/h2&gt;
&lt;p&gt;fPrimary 변수는 G4ParticleGun 클래스 객체의 포인터라고 하였습니다. 이 클래스에서 초기 입자의 특성을 설정하기 위해 제공하는 함수 중 대표적으로 몇 가지를 알아봅시다.&lt;/p&gt;
&lt;h3 id=&#34;입자의-종류&#34;&gt;입자의 종류&lt;/h3&gt;
&lt;p&gt;입자의 종류를 설정하기 위한 함수로, SetParticleDefinition이라는 함수를 제공합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetParticleDefinition(G4ParticleDefinition* aParticleDefinition);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;G4ParticleDefinition이라는 클래스가 생소하실텐데요, Geant4에서 입자에 대한 정의를 담당하는 클래스라고만 해두고 넘어가겠습니다.&lt;/p&gt;
&lt;p&gt;Geant4가 기본적으로 지원하는 입자의 모든 종류는 &lt;a href=&#34;https://geant4.kek.jp/Reference/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Geant4 Doxygen&lt;/a&gt;에서 G4ParticleDefinition 클래스의 레퍼런스 페이지(&lt;a href=&#34;https://geant4.kek.jp/Reference/10.07.p01/classG4ParticleDefinition.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10.7.p01 버전&lt;/a&gt;)에 들어가면 상속받은 클래스 목록(&lt;em&gt;Inheritance diagram for G4VSolid&lt;/em&gt;)에서 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    모든 입자를 초기 입자로 사용할 수 있는 것은 아닙니다. 일부 입자는 초기 입자로 설정하는 것이 불가능한 경우도 있습니다.
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;사실, Geant4 프로그램에서 사용 가능한 입자는 그 프로그램에서 어떤 PhysicsLists를 사용하느냐에 따라 좌우됩니다. 하지만 이 시리즈에서는 PhysicsLists를 아예 다루지 않을 예정이므로, 그냥 넘어가도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;참고로 &lt;code&gt;g4_minimal&lt;/code&gt; 템플릿 코드는 QBBC 물리모델을 사용하고 있습니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;여기서는 대표적으로 몇 가지 입자만 언급하도록 하겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Geantino, Charged Geantino&lt;/p&gt;
&lt;p&gt;각각 G4Geantino 클래스, G4ChargedGeantino 클래스를 통해 이용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;Geantino란 Geant4에서 정의한 가상의 입자로, 질량/스핀/parity가 0이며 어떠한 반응도 일으키지 않는 중성 입자입니다.&lt;/p&gt;
&lt;p&gt;Charged Geantino는 Geantino와 기본적인 특성은 동일하나, 전하만 +1인 입자입니다.&lt;/p&gt;
&lt;p&gt;이 두 가지 입자는 시뮬레이션의 검증단계에서 주로 활용됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gamma&lt;/p&gt;
&lt;p&gt;G4Gamma 클래스를 통해 이용할 수 있습니다. 일반적으로 알려진 광자(Photon)에 해당합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Electron, Positron&lt;/p&gt;
&lt;p&gt;각각 G4Electron 클래스, G4Positron 클래스를 통해 이용할 수 있습니다. 일반적으로 알려진 전자(Electron)와 양전자(Positron)에 해당합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proton&lt;/p&gt;
&lt;p&gt;G4Proton 클래스를 통해 이용 가능합니다. 일반적으로 알려진 양성자(Proton)에 해당합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Neutron&lt;/p&gt;
&lt;p&gt;G4Neutron 클래스를 통해 이용 가능합니다. 일반적으로 알려진 중성자(Neutron)에 해당합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Muon, Antimuon&lt;/p&gt;
&lt;p&gt;각각 G4MuonMinus 클래스, G4MuonPlus 클래스를 통해 이용 가능합니다. 일반적으로 알려진 뮤온(Muon)과 반뮤온(Antimuon)에 해당합니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;모든 입자 클래스들은 &lt;strong&gt;각 입자의 ParticleDefinition 클래스 객체의 포인터를 반환하는 static 함수&lt;/strong&gt;인 &lt;b&gt;Definition() 함수를 제공&lt;/b&gt;합니다. 즉, 어느 입자를 사용하든 &lt;code&gt;클래스명::Definition()&lt;/code&gt;이라고 입력하여 그 입자의 ParticleDefinition을 가져올 수 있습니다. 예를 들어 G4Gamma 클래스라면, &lt;code&gt;G4Gamma::Definition()&lt;/code&gt;과 같이 말이죠.&lt;/p&gt;
&lt;p&gt;여러가지 입자를 알아보았으니, 이들을 초기 입자로 설정하는 방법을 살펴봅시다. 다음의 두 단계를 거치면 됩니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;해당 입자의 클래스 헤더를 포함시킴&lt;/li&gt;
&lt;li&gt;SetParticleDefinition 함수를 이용하여 해당 입자를 초기 입자로 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;예를 들어 Gamma를 초기 입자로 설정하고 싶다면, 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;G4Gamma.hh&amp;quot; // Include header for G4Gamma class
// ...    
void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
{
    fPrimary-&amp;gt;SetParticleDefinition(G4Gamma::Definition()); // Set primary as gamma    

    fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 코드는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;02_setparticledefinition&#34; srcset=&#34;
               /g4-noqasked-008-prigen/02_setparticledefinition_hu0f59cf3940c1654cbfe8203e02958934_18352_32d167492c24a95a6988e59e6df349a6.png 400w,
               /g4-noqasked-008-prigen/02_setparticledefinition_hu0f59cf3940c1654cbfe8203e02958934_18352_3e132e414c0571d63c8b21583388fed6.png 760w,
               /g4-noqasked-008-prigen/02_setparticledefinition_hu0f59cf3940c1654cbfe8203e02958934_18352_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/02_setparticledefinition_hu0f59cf3940c1654cbfe8203e02958934_18352_32d167492c24a95a6988e59e6df349a6.png&#34;
               width=&#34;575&#34;
               height=&#34;486&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이렇게 변경한 뒤, Tracking Verbose를 1레벨로 하여 출력해보면 다음과 같이 초기 입자가 바뀐 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;03_setparticledefinitionrslt&#34; srcset=&#34;
               /g4-noqasked-008-prigen/03_setparticledefinitionrslt_hu488620115a5d4793e904e992734ddaec_15184_17a904d86ad3619546894a5dbf3cba5b.png 400w,
               /g4-noqasked-008-prigen/03_setparticledefinitionrslt_hu488620115a5d4793e904e992734ddaec_15184_e7708c1df2f45f8c1e84b7afc5eb8a4f.png 760w,
               /g4-noqasked-008-prigen/03_setparticledefinitionrslt_hu488620115a5d4793e904e992734ddaec_15184_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/03_setparticledefinitionrslt_hu488620115a5d4793e904e992734ddaec_15184_17a904d86ad3619546894a5dbf3cba5b.png&#34;
               width=&#34;760&#34;
               height=&#34;133&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;입자의-운동에너지&#34;&gt;입자의 운동에너지&lt;/h3&gt;
&lt;p&gt;입자의 운동에너지를 설정하기 위한 함수로, SetParticleEnergy라는 함수를 제공합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetParticleEnergy(G4double aKineticEnergy);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;입력 인자는 간단하게 G4double형입니다. 다만, 에너지에 대한 &lt;strong&gt;단위를 입력&lt;/strong&gt;할 필요가 있으므로, &lt;strong&gt;G4SystemOfUnits 헤더를 포함&lt;/strong&gt;시켜줘야 한다는 점에 주의하세요.&lt;/p&gt;
&lt;p&gt;예를 들어 초기 입자의 운동에너지를 0.662 MeV로 설정하고 싶다면, 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;G4SystemOfUnits.hh&amp;quot; // Include header for unit system
// ...    
void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
{
    // ...
    fPrimary-&amp;gt;SetParticleEnergy(0.662 * MeV);

    fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 코드는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;04_setparticleenergy&#34; srcset=&#34;
               /g4-noqasked-008-prigen/04_setparticleenergy_hu723eecd2d086adadc0bdf7dcd8a42271_21073_72d3cc1c6e76a903441ff7078da8534a.png 400w,
               /g4-noqasked-008-prigen/04_setparticleenergy_hu723eecd2d086adadc0bdf7dcd8a42271_21073_9a40539c79b2b87f91f63d4f3a6bc1fc.png 760w,
               /g4-noqasked-008-prigen/04_setparticleenergy_hu723eecd2d086adadc0bdf7dcd8a42271_21073_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/04_setparticleenergy_hu723eecd2d086adadc0bdf7dcd8a42271_21073_72d3cc1c6e76a903441ff7078da8534a.png&#34;
               width=&#34;573&#34;
               height=&#34;535&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이렇게 변경한 뒤, Tracking Verbose를 1레벨로 하여 출력해보면 다음과 같이 초기 입자의 운동에너지가 바뀐 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;05_setparticleenergyrslt&#34; srcset=&#34;
               /g4-noqasked-008-prigen/05_setparticleenergyrslt_hu6fb20b56156bc46b506c039095da0715_12796_a2c6ab58f653520a67bedb24f6b8f3fd.png 400w,
               /g4-noqasked-008-prigen/05_setparticleenergyrslt_hu6fb20b56156bc46b506c039095da0715_12796_790d84a259618e38d34a8be38090c265.png 760w,
               /g4-noqasked-008-prigen/05_setparticleenergyrslt_hu6fb20b56156bc46b506c039095da0715_12796_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/05_setparticleenergyrslt_hu6fb20b56156bc46b506c039095da0715_12796_a2c6ab58f653520a67bedb24f6b8f3fd.png&#34;
               width=&#34;760&#34;
               height=&#34;129&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;입자의-위치&#34;&gt;입자의 위치&lt;/h3&gt;
&lt;p&gt;입자의 위치를 설정하기 위한 함수로, SetParticlePosition이라는 함수를 제공합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetParticlePosition(G4ThreeVector aPosition);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;입력 인자는 G4ThreeVector 객체입니다.&lt;/p&gt;
&lt;p&gt;예를 들어 초기 입자의 위치를 (0, 0, 0)으로 설정하고 싶다면, 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// ...    
void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
{
    // ...
    fPrimary-&amp;gt;SetParticlePosition(G4ThreeVector());

    fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 코드는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;06_setparticleposition&#34; srcset=&#34;
               /g4-noqasked-008-prigen/06_setparticleposition_hudfe6f7b07e77ba648b03613a17774985_22737_ce85bc46944af188b7a916de325e4b9e.png 400w,
               /g4-noqasked-008-prigen/06_setparticleposition_hudfe6f7b07e77ba648b03613a17774985_22737_417820f43384d8ef4d11154e1b97679d.png 760w,
               /g4-noqasked-008-prigen/06_setparticleposition_hudfe6f7b07e77ba648b03613a17774985_22737_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/06_setparticleposition_hudfe6f7b07e77ba648b03613a17774985_22737_ce85bc46944af188b7a916de325e4b9e.png&#34;
               width=&#34;571&#34;
               height=&#34;553&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이 부분은 원래 기본 값이 (0, 0, 0)이어서 바뀌지 않습니다만, 원하는 값으로 변경해보시면 Tracking Verbose에서 차이를 확인할 수 있을 것입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;07_setparticlepositionrslt&#34; srcset=&#34;
               /g4-noqasked-008-prigen/07_setparticlepositionrslt_hu57c934c62944e5929fbbcaf7ecb2400e_9995_38dde91404d968c12583d9d4fd2fd0a6.png 400w,
               /g4-noqasked-008-prigen/07_setparticlepositionrslt_hu57c934c62944e5929fbbcaf7ecb2400e_9995_37483691aa7047e41598af9b054b59fd.png 760w,
               /g4-noqasked-008-prigen/07_setparticlepositionrslt_hu57c934c62944e5929fbbcaf7ecb2400e_9995_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/07_setparticlepositionrslt_hu57c934c62944e5929fbbcaf7ecb2400e_9995_38dde91404d968c12583d9d4fd2fd0a6.png&#34;
               width=&#34;760&#34;
               height=&#34;131&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h3 id=&#34;입자의-운동방향&#34;&gt;입자의 운동방향&lt;/h3&gt;
&lt;p&gt;입자의 운동방향을 설정하기 위한 함수로, SetParticleMomentumDirection이라는 함수를 제공합니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SetParticleMomentumDirection(G4ParticleMomentum aMomDirection);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;입력 인자는 G4ParticleMomentum라고 적혀있습니다만, 이는 사실 &lt;strong&gt;G4ThreeVector의 다른 이름&lt;/strong&gt;일 뿐입니다. 위치 때와 동일하게 G4ThreeVector 객체를 넣으시면 됩니다.&lt;/p&gt;
&lt;p&gt;예를 들어 초기 입자의 운동방향을 +Z축인 (0, 0, 1)으로 설정하고 싶다면, 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// ...    
void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
{
    // ...
    fPrimary-&amp;gt;SetParticleMomentumDirection(G4ThreeVector(0., 0., 1.));

    fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 코드는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;08_setparticlemomentumdirection&#34; srcset=&#34;
               /g4-noqasked-008-prigen/08_setparticlemomentumdirection_hu711af9a3c69fa0f79db13905504a5ef3_25334_d3c7202ba3168b69a057053b23ad60d7.png 400w,
               /g4-noqasked-008-prigen/08_setparticlemomentumdirection_hu711af9a3c69fa0f79db13905504a5ef3_25334_4f9e537a4ad072023f1696b548480044.png 760w,
               /g4-noqasked-008-prigen/08_setparticlemomentumdirection_hu711af9a3c69fa0f79db13905504a5ef3_25334_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/08_setparticlemomentumdirection_hu711af9a3c69fa0f79db13905504a5ef3_25334_d3c7202ba3168b69a057053b23ad60d7.png&#34;
               width=&#34;624&#34;
               height=&#34;572&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이렇게 변경한 뒤, Tracking Verbose를 1레벨로 하여 출력해보면 다음과 같이 초기 입자의 진행 방향이 바뀐 것을 확인할 수 있습니다. 제가 보여드리는 예제 코드의 경우 +Z축 방향에 앞서 정의했던 phantom이 있다보니, 감마선이 이 지오메트리와 충돌하여 여러 반응이 일어나는 모습까지 확인이 되네요.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;09_setparticlemomentumdirectionrslt&#34; srcset=&#34;
               /g4-noqasked-008-prigen/09_setparticlemomentumdirectionrslt_hu48327c2aac8118a064012d88cf4859bb_17710_4794c0e4c10aef43da3be01ec950b861.png 400w,
               /g4-noqasked-008-prigen/09_setparticlemomentumdirectionrslt_hu48327c2aac8118a064012d88cf4859bb_17710_862a9523061b48789d80e2e594b22541.png 760w,
               /g4-noqasked-008-prigen/09_setparticlemomentumdirectionrslt_hu48327c2aac8118a064012d88cf4859bb_17710_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/09_setparticlemomentumdirectionrslt_hu48327c2aac8118a064012d88cf4859bb_17710_4794c0e4c10aef43da3be01ec950b861.png&#34;
               width=&#34;760&#34;
               height=&#34;179&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ui로-확인해보기&#34;&gt;UI로 확인해보기&lt;/h2&gt;
&lt;p&gt;지금까지 변경한 내용을 UI로 실행하면 그래픽으로 살펴볼 수도 있습니다. build 디렉토리에서 &lt;code&gt;./g4_minimal&lt;/code&gt;을 입력하여 실행해서 UI창을 띄워봅니다. 다음 그림과 같이 Geometry가 보일 것입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;10_UI&#34; srcset=&#34;
               /g4-noqasked-008-prigen/10_UI_hub5e4f9dda5c9a6f8d964f69a1fd36abf_73842_076316abb158d7397cdc3766a289694d.png 400w,
               /g4-noqasked-008-prigen/10_UI_hub5e4f9dda5c9a6f8d964f69a1fd36abf_73842_e35f5674f5225dadafb15f58df8dd1fa.png 760w,
               /g4-noqasked-008-prigen/10_UI_hub5e4f9dda5c9a6f8d964f69a1fd36abf_73842_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/10_UI_hub5e4f9dda5c9a6f8d964f69a1fd36abf_73842_076316abb158d7397cdc3766a289694d.png&#34;
               width=&#34;760&#34;
               height=&#34;591&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;여기서, 그림 하단에 빨간색으로 표시해 둔 &lt;strong&gt;Session&lt;/strong&gt; 입력창에 &lt;code&gt;/run/beamOn 100&lt;/code&gt;이라고 입력한 뒤 [Enter]를 누르면 UI 상에서 &lt;b&gt;Event 100개 묶음의 Run 한 번을 실행&lt;/b&gt;시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;11_UIrun&#34; srcset=&#34;
               /g4-noqasked-008-prigen/11_UIrun_hudbcfa44ff639751693ce0a4c74436e4a_100196_43b606df937559c06b35a8a552159ca8.png 400w,
               /g4-noqasked-008-prigen/11_UIrun_hudbcfa44ff639751693ce0a4c74436e4a_100196_c520ed811f275c39ea2b4700ebb54635.png 760w,
               /g4-noqasked-008-prigen/11_UIrun_hudbcfa44ff639751693ce0a4c74436e4a_100196_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/11_UIrun_hudbcfa44ff639751693ce0a4c74436e4a_100196_43b606df937559c06b35a8a552159ca8.png&#34;
               width=&#34;760&#34;
               height=&#34;591&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;좀 확대해보시면 다음과 같은 모습을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;12_UIrunzoom&#34; srcset=&#34;
               /g4-noqasked-008-prigen/12_UIrunzoom_hu1009d96c1c1bedee9f979a794bb8fb49_132265_e87d8394edee414b94fdf74853e97057.png 400w,
               /g4-noqasked-008-prigen/12_UIrunzoom_hu1009d96c1c1bedee9f979a794bb8fb49_132265_81bde08eb3fff2fd48a12da5047b4111.png 760w,
               /g4-noqasked-008-prigen/12_UIrunzoom_hu1009d96c1c1bedee9f979a794bb8fb49_132265_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-008-prigen/12_UIrunzoom_hu1009d96c1c1bedee9f979a794bb8fb49_132265_e87d8394edee414b94fdf74853e97057.png&#34;
               width=&#34;760&#34;
               height=&#34;393&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    그래픽에서 보이는 선이나 점의 색상은 &lt;code&gt;vis.mac&lt;/code&gt; 등에서 설정한 값에 따라 달라질 수 있습니다.
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;기본적으로는 다음과 같이 해석하시면 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;노란점: 입자를 수송하던 중, Track이 기록된 분절점의 위치&lt;/li&gt;
&lt;li&gt;초록선: Charge가 중성인 입자의 궤적(이 예시에서는 Gamma 입자에 해당함)&lt;/li&gt;
&lt;li&gt;빨간선: Charge가 음성(-)인 입자의 궤적(이 예시에서는 Electron 입자에 해당함)&lt;/li&gt;
&lt;li&gt;파란선: Charge가 양성(+)인 입자의 궤적(이 예시에서는 나타나지 않음)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;정리&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;이번 글에서는 초기 입자의 정보를 설정하고 확인하는 방법에 대해 살펴보았습니다. 그러나 이런식으로 입력하면, &lt;strong&gt;항상 동일한 조건의 초기 입자만 발생&lt;/strong&gt;될 것입니다.&lt;/p&gt;
&lt;p&gt;다음 글에서는 G4RandomTools 헤더를 활용하여, Event 마다 초기 입자의 위치나 방향을 변경하며 발생시키는 방법에 대해 알아보겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Geant4 무작정 따라하기 - 9. 확률변수 이용하여 선원항 정의하기</title>
      <link>https://evandde.github.io/g4-noqasked-009-randtool/</link>
      <pubDate>Fri, 16 Jul 2021 14:43:20 +0900</pubDate>
      <guid>https://evandde.github.io/g4-noqasked-009-randtool/</guid>
      <description>&lt;p&gt;Geant4 무작정 따라하기 시리즈의 아홉번째. 확률변수를 이용하여 Event마다 바뀌는 선원항을 정의하는 방법을 알아봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;등방성-점선원-모사&#34;&gt;등방성 점선원 모사&lt;/h2&gt;
&lt;h3 id=&#34;문제-제기&#34;&gt;문제 제기&lt;/h3&gt;
&lt;p&gt;등방적으로 발생하는 점선원을 생각해봅시다. 일반적으로 다음 그림과 같은 모양이 떠오를 것입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;01_isotropic&#34; srcset=&#34;
               /g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_3b814b4b544ccedf3310aca84e937ff9.png 400w,
               /g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_db54ba0ace8e9c842bb631f984d25fe2.png 760w,
               /g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_3b814b4b544ccedf3310aca84e937ff9.png&#34;
               width=&#34;760&#34;
               height=&#34;591&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;하지만 앞서 말씀드린 것처럼 Geant4는 한 번에 하나의 입자만을 수송하기 때문에, 실제로는 다음과 같이 매 Event마다 방향이 바뀌는 입자가 순차적으로 나오는 형태일 것입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;02_isotropic&#34;
           src=&#34;https://evandde.github.io/g4-noqasked-009-randtool/02_isotropic.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이제 앞서 배운 선원항의 방향 정의 부분을 다시 살펴봅시다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어 초기 입자의 운동방향을 +Z축인 (0, 0, 1)으로 설정하고 싶다면, 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; // ...    
 void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
 {
     // ...
     fPrimary-&amp;gt;SetParticleMomentumDirection(G4ThreeVector(0., 0., 1.));

     fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;SetParticleMomentumDirection 함수를 통해 방향을 설정하고, 이 때 방향은 &lt;strong&gt;G4ThreeVector 형태로 입력&lt;/strong&gt;을 해주어야 합니다. 우리는 결국 &lt;strong&gt;방향&lt;/strong&gt;을 &lt;strong&gt;명시해서 입력&lt;/strong&gt;해 줘야만 하는데, 이 &lt;strong&gt;방향이 알아서 매 번 바뀌어야 하는 상황&lt;/strong&gt;에 놓였습니다.&lt;/p&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;p&gt;이 문제를 해결하기 위해 다음과 같은 함수를 상상해봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 함수는 &lt;strong&gt;G4ThreeVector를 반환&lt;/strong&gt;하는데, &lt;strong&gt;함수가 호출될 때마다 반환되는 값이 매번 바뀝니다&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반환되는 G4ThreeVector들을 쭉 모아서 &lt;strong&gt;분포&lt;/strong&gt;를 살펴보니, &lt;b&gt;단위구(Unit sphere) 표면 위의 점이 균일한 확률&lt;/b&gt;로 나옵니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector RandomDirection();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 함수를 어떻게 만들 수 있을 지는 나중에 생각해보기로 하고, 이 함수의 출력값을 먼저 살펴봅시다. 아마도 다음과 같이 나타날 것입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector dir;

dir = RandomDirection(); // dir = G4ThreeVector(-0.157616,-0.293535,-0.942865);
dir = RandomDirection(); // dir = G4ThreeVector(0.185649,-0.743512,0.642437);
dir = RandomDirection(); // dir = G4ThreeVector(0.643525,0.268099,0.716937);
dir = RandomDirection(); // dir = G4ThreeVector(0.636717,-0.421678,0.645584);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;바로 이 RandomDirection() 함수가 바로 우리가 원하던 &lt;strong&gt;방향을 등방적으로 균일하게 매 번 알아서 바꾸어서 제공해주는 함수&lt;/strong&gt;입니다. 이런 함수만 있다면 선원항을 다음과 같이 정의하여 우리의 문제를 해결할 수 있겠군요. 다음과 같이 말입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// ...    
void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
{
  // ...
  auto dir = RandomDirection();
  fPrimary-&amp;gt;SetParticleMomentumDirection(dir);

  fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;설명&#34;&gt;설명&lt;/h3&gt;
&lt;p&gt;이처럼 특정한 확률분포(Probability Distribution Function, PDF)를 따라 변하는 수를 확률변수라고 합니다. 그리고 이렇게 확률변수를 생성해내는 행위를 샘플링(sampling)한다고 합니다.&lt;/p&gt;
&lt;p&gt;확률변수에 있어 가장 기본이 되는 것은, 소위 난수(random number)라고 불리는 $ \xi \sim \mathcal{U}(0,1) $입니다. 0~1 범위 내의 실수가 균일하게 샘플링되는 난수 $ \xi $를 반환하는 함수는 대부분의 프로그래밍 언어가 기본으로 제공하고 있습니다&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. 이 $ \xi $만 있으면, 이론상 &lt;b&gt;임의의 PDF를 따르는 확률변수를 샘플링하는 함수&lt;/b&gt;를 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 이 부분은 수학적인 기교가 들어가는 내용이므로 여기서 다루지는 않겠습니다.&lt;/p&gt;
&lt;p&gt;중요한 점은, 이렇게 &lt;strong&gt;확률변수를 샘플링하는 함수&lt;/strong&gt;만 있으면 &lt;strong&gt;매 번 발생 조건이 바뀌는 선원항도 정의할 수 있게 된다&lt;/strong&gt;는 것입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;g4randomtoolshh&#34;&gt;G4RandomTools.hh&lt;/h2&gt;
&lt;p&gt;Geant4는 &lt;font color=red&gt;&lt;b&gt;G4RandomTools.hh&lt;/b&gt;&lt;/font&gt;라는 헤더를 통해, 자주 사용되는 PDF에 대해 &lt;strong&gt;확률변수를 샘플링하는 다양한 함수를 이미 만들어서 제공&lt;/strong&gt;하고 있습니다. 덕분에 이러한 함수를 굳이 공부하여 만들어 쓸 필요가 없습니다.&lt;/p&gt;
&lt;p&gt;대표적인 함수들을 일부 소개해드리겠습니다. (10.7 버전 기준)&lt;/p&gt;
&lt;h3 id=&#34;g4randomdirection&#34;&gt;G4RandomDirection&lt;/h3&gt;
&lt;p&gt;앞서 설명했던, 등방적으로 방향을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4RandomDirection();
G4ThreeVector G4RandomDirection(G4double cosTheta);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 입력인자를 아예 입력하지 않고 사용할 수 있습니다. 이 경우 모든 방향($ 4\pi $)에 대해 균일하게 샘플링된 G4ThreeVector를 반환받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;혹은, 입력인자로 임의의 각도 $ \theta $에 대해 $ \mathcal{cos} \theta $ 값에 해당하는 실수(G4double)를 넣을 수도 있습니다. 이 경우에는 $ +z $축을 중심축으로 하고 꼭짓각의 절반이 $ \theta $인 원뿔 형태로 제한된 영역에 대해 균일하게 샘플링된 G4ThreeVector를 반환받을 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;g4lambertianrand&#34;&gt;G4LambertianRand&lt;/h3&gt;
&lt;p&gt;입력된 벡터를 법선벡터로 갖는 평면에 대해 Lambert 코사인 법칙&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;을 따르게끔 방향을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4LambertianRand(const G4ThreeVector&amp;amp; normal);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 입력인자로 G4ThreeVector 하나를 넣어줘야 합니다. 그러면 그 벡터를 법선벡터(normal vector)로 갖는 평면을 기준으로 하여 Lambert 코사인 법칙을 따르는 방향을 샘플링하여 G4ThreeVector 형태로 반환해 줍니다.&lt;/p&gt;
&lt;h3 id=&#34;g4planevectorrand&#34;&gt;G4PlaneVectorRand&lt;/h3&gt;
&lt;p&gt;입력된 벡터를 법선벡터로 갖는 무한 평면상의 점을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4PlaneVectorRand(const G4ThreeVector&amp;amp; normal);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 입력인자로 G4ThreeVector 하나를 넣어줘야 합니다. 그러면 그 벡터를 법선벡터(normal vector)로 갖는 무한평면 상의 한 지점을 샘플링하여 G4ThreeVector 형태로 반환받을 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randomradiusinring&#34;&gt;G4RandomRadiusInRing&lt;/h3&gt;
&lt;p&gt;평면 원 혹은 평면 고리에서 균일한 분포의 점을 샘플링 하기 위한 &lt;strong&gt;반경&lt;/strong&gt;의 샘플링을 수행해주는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4double G4RandomRadiusInRing(G4double rmin, G4double rmax);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원이면 rmin을 0으로, rmax를 반지름으로 주면 됩니다. 고리라면 rmin을 내경으로, rmax를 외경으로 주면 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randompointinellipse&#34;&gt;G4RandomPointInEllipse&lt;/h3&gt;
&lt;p&gt;평면 타원 내에서 균일한 분포의 &lt;strong&gt;2차원 점&lt;/strong&gt;을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4TwoVector G4RandomPointInEllipse(G4double a, G4double b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ {x^2 \over a^2} +  {y^2 \over b^2} = 1 $의 타원의 방정식을 따르는 평면 타원에 대해 $a$, $b$를 입력인자로 넣으면, 타원 내에서 균일한 분포의 2차원 점을 샘플링하여 반환해줍니다. G4TwoVector는 2차원 벡터를 다루는 클래스로,  G4ThreeVector와 유사하게 사용하면 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randompointonellipse&#34;&gt;G4RandomPointOnEllipse&lt;/h3&gt;
&lt;p&gt;평면 타원의 &lt;strong&gt;원주 위&lt;/strong&gt;에서 균일한 분포의 &lt;strong&gt;2차원 점&lt;/strong&gt;을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4TwoVector G4RandomPointOnEllipse(G4double a, G4double b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ {x^2 \over a^2} +  {y^2 \over b^2} = 1 $의 타원의 방정식을 따르는 평면 타원에 대해 $a$, $b$를 입력인자로 넣으면, 타원의 원주 위에서 균일한 분포의 2차원 점을 샘플링하여 반환해줍니다. &lt;b&gt;In과 On의 차이에 주의하세요&lt;/b&gt;.&lt;/p&gt;
&lt;h3 id=&#34;g4randompointonellipsoid&#34;&gt;G4RandomPointOnEllipsoid&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3차원 타원체의 표면 위&lt;/strong&gt;에서 균일한 분포의 &lt;strong&gt;3차원 점&lt;/strong&gt;을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4RandomPointOnEllipsoid(G4double a, G4double b, G4double c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ {x^2 \over a^2} +  {y^2 \over b^2} + {z^2 \over c^2} = 1 $의 타원체의 방정식을 따르는 3차원 타원체에 대해 $a$, $b$, $c$를 입력인자로 넣으면, 타원체의 겉표면 위에서 균일한 분포의 3차원 점을 샘플링하여 반환해줍니다.&lt;/p&gt;
&lt;h3 id=&#34;g4uniformrand&#34;&gt;G4UniformRand&lt;/h3&gt;
&lt;p&gt;$ X \sim \mathcal{U}(0,1) $를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double G4UniformRand();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;g4randflatshoot&#34;&gt;G4RandFlat::shoot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;균등분포&lt;/strong&gt;를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double shoot(double a, double b); // example: G4RandFlat::shoot(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ X \sim \mathcal{U}(a,b) $를 따르는 확률변수 $ X $를 샘플링하는 함수입니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randgaussqshoot&#34;&gt;G4RandGaussQ::shoot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;정규분포&lt;/strong&gt;를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double shoot(double mean, double stdDev); // example: G4RandGaussQ::shoot(mean, stdDev)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;평균(mean)이 $\mu$이고, 표준편차(stdDev)가 $\sigma$인 $ X \sim \mathcal{N}(\mu , {\sigma}^2) $를 따르는 확률변수 $ X $를 샘플링하는 함수입니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randexponentialshoot&#34;&gt;G4RandExponential::shoot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;지수분포&lt;/strong&gt;를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double shoot(double mean); // example: G4RandExponential::shoot(mean)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;평균(mean)이 $\lambda$인 $ X \sim Exp(\lambda) $를 따르는 확률변수 $ X $를 샘플링하는 함수입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;실제-적용---등방성-점선원&#34;&gt;실제 적용 - 등방성 점선원&lt;/h2&gt;
&lt;p&gt;이제 맨처음 고민하였던 등방성 점선원을 모사하는 방법을 모두 알아냈습니다.&lt;/p&gt;
&lt;p&gt;PrimaryGeneratorAction 코드를 다음과 같이 작성하면 등방성 점선원을 모사할 수 있게 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤더 &lt;b&gt;G4RandomTools.hh&lt;/b&gt;를 포함&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SetParticleMomentumDirection() 함수의 입력 인자&lt;/strong&gt;로, &lt;strong&gt;G4RandomDirection() 함수의 출력값&lt;/strong&gt;을 대입&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;실제 소스코드는 다음과 같이 작성하면 됩니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;03_isotropic_code&#34; srcset=&#34;
               /g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_06f7655ae73400be0b340c2d8c09eaa6.png 400w,
               /g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_73906b086d23b6828dd99db790e906a2.png 760w,
               /g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_06f7655ae73400be0b340c2d8c09eaa6.png&#34;
               width=&#34;650&#34;
               height=&#34;641&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;최종-파일-다운받는-법&#34;&gt;최종 파일 다운받는 법&lt;/h2&gt;
&lt;p&gt;이번 글에서 작성한 코드는 &lt;a href=&#34;https://github.com/evandde/g4_minimal/archive/e9016a9ad32b755390ef66c16bb89557c7cc7119.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;이 링크&lt;/a&gt;를 통해 다운받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;혹은 git repository를 clone하신 분의 경우에는, example branch의 이전 커밋 중 V2 PriGen이라는 커밋을 참고하셔도 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;정리&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;이로써 선원항을 정의하는 방법까지 마쳤습니다.&lt;/p&gt;
&lt;p&gt;다음 글에서는 시뮬레이션을 돌리며 원하는 정보를 획득하는 &lt;strong&gt;스코어링&lt;/strong&gt;에 대해 살펴보도록 하겠습니다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;사실 컴퓨터는 완전히 무작위적인 난수를 발생시키지는 못해서 의사난수(pseudo random number)를 샘플링하는 함수들을 제공합니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;이상적인 난반사 표면에서 방출되는 선속이 법선벡터로부터 벗어난 각도의 $ \mathcal{cos} $ 값에 비례한다는 법칙. 참고 링크: &lt;a href=&#34;https://en.wikipedia.org/wiki/Lambert%27s_cosine_law&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lambert&amp;rsquo;s cosine law - Wikipedia&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
  </channel>
</rss>
