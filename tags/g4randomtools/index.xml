<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>G4RandomTools | EvaNote</title>
    <link>https://evandde.github.io/tags/g4randomtools/</link>
      <atom:link href="https://evandde.github.io/tags/g4randomtools/index.xml" rel="self" type="application/rss+xml" />
    <description>G4RandomTools</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>ko-kr</language><copyright>© 2020–2021 Evan Kim</copyright><lastBuildDate>Fri, 16 Jul 2021 14:43:20 +0900</lastBuildDate>
    <image>
      <url>https://evandde.github.io/media/icon_hu8e7e87b14a52eedd9109bf1b224bd29e_18847_512x512_fill_lanczos_center_3.png</url>
      <title>G4RandomTools</title>
      <link>https://evandde.github.io/tags/g4randomtools/</link>
    </image>
    
    <item>
      <title>Geant4 무작정 따라하기 - 9. 확률변수 이용하여 선원항 정의하기</title>
      <link>https://evandde.github.io/g4-noqasked-009-randtool/</link>
      <pubDate>Fri, 16 Jul 2021 14:43:20 +0900</pubDate>
      <guid>https://evandde.github.io/g4-noqasked-009-randtool/</guid>
      <description>&lt;p&gt;Geant4 무작정 따라하기 시리즈의 아홉번째. 확률변수를 이용하여 Event마다 바뀌는 선원항을 정의하는 방법을 알아봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;등방성-점선원-모사&#34;&gt;등방성 점선원 모사&lt;/h2&gt;
&lt;h3 id=&#34;문제-제기&#34;&gt;문제 제기&lt;/h3&gt;
&lt;p&gt;등방적으로 발생하는 점선원을 생각해봅시다. 일반적으로 다음 그림과 같은 모양이 떠오를 것입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;01_isotropic&#34; srcset=&#34;
               /g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_3b814b4b544ccedf3310aca84e937ff9.png 400w,
               /g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_db54ba0ace8e9c842bb631f984d25fe2.png 760w,
               /g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-009-randtool/01_isotropic_huf6baa88101f874f0c3ede1f096d1d7af_58450_3b814b4b544ccedf3310aca84e937ff9.png&#34;
               width=&#34;760&#34;
               height=&#34;591&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;하지만 앞서 말씀드린 것처럼 Geant4는 한 번에 하나의 입자만을 수송하기 때문에, 실제로는 다음과 같이 매 Event마다 방향이 바뀌는 입자가 순차적으로 나오는 형태일 것입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;02_isotropic&#34;
           src=&#34;https://evandde.github.io/g4-noqasked-009-randtool/02_isotropic.gif&#34;
           loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이제 앞서 배운 선원항의 방향 정의 부분을 다시 살펴봅시다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어 초기 입자의 운동방향을 +Z축인 (0, 0, 1)으로 설정하고 싶다면, 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; // ...    
 void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
 {
     // ...
     fPrimary-&amp;gt;SetParticleMomentumDirection(G4ThreeVector(0., 0., 1.));

     fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;SetParticleMomentumDirection 함수를 통해 방향을 설정하고, 이 때 방향은 &lt;strong&gt;G4ThreeVector 형태로 입력&lt;/strong&gt;을 해주어야 합니다. 우리는 결국 &lt;strong&gt;방향&lt;/strong&gt;을 &lt;strong&gt;명시해서 입력&lt;/strong&gt;해 줘야만 하는데, 이 &lt;strong&gt;방향이 알아서 매 번 바뀌어야 하는 상황&lt;/strong&gt;에 놓였습니다.&lt;/p&gt;
&lt;h3 id=&#34;해결책&#34;&gt;해결책&lt;/h3&gt;
&lt;p&gt;이 문제를 해결하기 위해 다음과 같은 함수를 상상해봅시다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이 함수는 &lt;strong&gt;G4ThreeVector를 반환&lt;/strong&gt;하는데, &lt;strong&gt;함수가 호출될 때마다 반환되는 값이 매번 바뀝니다&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;반환되는 G4ThreeVector들을 쭉 모아서 &lt;strong&gt;분포&lt;/strong&gt;를 살펴보니, &lt;b&gt;단위구(Unit sphere) 표면 위의 점이 균일한 확률&lt;/b&gt;로 나옵니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수의 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector RandomDirection();
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 함수를 어떻게 만들 수 있을 지는 나중에 생각해보기로 하고, 이 함수의 출력값을 먼저 살펴봅시다. 아마도 다음과 같이 나타날 것입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector dir;

dir = RandomDirection(); // dir = G4ThreeVector(-0.157616,-0.293535,-0.942865);
dir = RandomDirection(); // dir = G4ThreeVector(0.185649,-0.743512,0.642437);
dir = RandomDirection(); // dir = G4ThreeVector(0.643525,0.268099,0.716937);
dir = RandomDirection(); // dir = G4ThreeVector(0.636717,-0.421678,0.645584);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;바로 이 RandomDirection() 함수가 바로 우리가 원하던 &lt;strong&gt;방향을 등방적으로 균일하게 매 번 알아서 바꾸어서 제공해주는 함수&lt;/strong&gt;입니다. 이런 함수만 있다면 선원항을 다음과 같이 정의하여 우리의 문제를 해결할 수 있겠군요. 다음과 같이 말입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// ...    
void PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent)
{
  // ...
  auto dir = RandomDirection();
  fPrimary-&amp;gt;SetParticleMomentumDirection(dir);

  fPrimary-&amp;gt;GeneratePrimaryVertex(anEvent);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;설명&#34;&gt;설명&lt;/h3&gt;
&lt;p&gt;이처럼 특정한 확률분포(Probability Distribution Function, PDF)를 따라 변하는 수를 확률변수라고 합니다. 그리고 이렇게 확률변수를 생성해내는 행위를 샘플링(sampling)한다고 합니다.&lt;/p&gt;
&lt;p&gt;확률변수에 있어 가장 기본이 되는 것은, 소위 난수(random number)라고 불리는 $ \xi \sim \mathcal{U}(0,1) $입니다. 0~1 범위 내의 실수가 균일하게 샘플링되는 난수 $ \xi $를 반환하는 함수는 대부분의 프로그래밍 언어가 기본으로 제공하고 있습니다&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. 이 $ \xi $만 있으면, 이론상 &lt;b&gt;임의의 PDF를 따르는 확률변수를 샘플링하는 함수&lt;/b&gt;를 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 이 부분은 수학적인 기교가 들어가는 내용이므로 여기서 다루지는 않겠습니다.&lt;/p&gt;
&lt;p&gt;중요한 점은, 이렇게 &lt;strong&gt;확률변수를 샘플링하는 함수&lt;/strong&gt;만 있으면 &lt;strong&gt;매 번 발생 조건이 바뀌는 선원항도 정의할 수 있게 된다&lt;/strong&gt;는 것입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;g4randomtoolshh&#34;&gt;G4RandomTools.hh&lt;/h2&gt;
&lt;p&gt;Geant4는 &lt;font color=red&gt;&lt;b&gt;G4RandomTools.hh&lt;/b&gt;&lt;/font&gt;라는 헤더를 통해, 자주 사용되는 PDF에 대해 &lt;strong&gt;확률변수를 샘플링하는 다양한 함수를 이미 만들어서 제공&lt;/strong&gt;하고 있습니다. 덕분에 이러한 함수를 굳이 공부하여 만들어 쓸 필요가 없습니다.&lt;/p&gt;
&lt;p&gt;대표적인 함수들을 일부 소개해드리겠습니다. (10.7 버전 기준)&lt;/p&gt;
&lt;h3 id=&#34;g4randomdirection&#34;&gt;G4RandomDirection&lt;/h3&gt;
&lt;p&gt;앞서 설명했던, 등방적으로 방향을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4RandomDirection();
G4ThreeVector G4RandomDirection(G4double cosTheta);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 입력인자를 아예 입력하지 않고 사용할 수 있습니다. 이 경우 모든 방향($ 4\pi $)에 대해 균일하게 샘플링된 G4ThreeVector를 반환받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;혹은, 입력인자로 임의의 각도 $ \theta $에 대해 $ \mathcal{cos} \theta $ 값에 해당하는 실수(G4double)를 넣을 수도 있습니다. 이 경우에는 $ +z $축을 중심축으로 하고 꼭짓각의 절반이 $ \theta $인 원뿔 형태로 제한된 영역에 대해 균일하게 샘플링된 G4ThreeVector를 반환받을 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;g4lambertianrand&#34;&gt;G4LambertianRand&lt;/h3&gt;
&lt;p&gt;입력된 벡터를 법선벡터로 갖는 평면에 대해 Lambert 코사인 법칙&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;을 따르게끔 방향을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4LambertianRand(const G4ThreeVector&amp;amp; normal);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 입력인자로 G4ThreeVector 하나를 넣어줘야 합니다. 그러면 그 벡터를 법선벡터(normal vector)로 갖는 평면을 기준으로 하여 Lambert 코사인 법칙을 따르는 방향을 샘플링하여 G4ThreeVector 형태로 반환해 줍니다.&lt;/p&gt;
&lt;h3 id=&#34;g4planevectorrand&#34;&gt;G4PlaneVectorRand&lt;/h3&gt;
&lt;p&gt;입력된 벡터를 법선벡터로 갖는 무한 평면상의 점을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4PlaneVectorRand(const G4ThreeVector&amp;amp; normal);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 함수는 입력인자로 G4ThreeVector 하나를 넣어줘야 합니다. 그러면 그 벡터를 법선벡터(normal vector)로 갖는 무한평면 상의 한 지점을 샘플링하여 G4ThreeVector 형태로 반환받을 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randomradiusinring&#34;&gt;G4RandomRadiusInRing&lt;/h3&gt;
&lt;p&gt;평면 원 혹은 평면 고리에서 균일한 분포의 점을 샘플링 하기 위한 &lt;strong&gt;반경&lt;/strong&gt;의 샘플링을 수행해주는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4double G4RandomRadiusInRing(G4double rmin, G4double rmax);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원이면 rmin을 0으로, rmax를 반지름으로 주면 됩니다. 고리라면 rmin을 내경으로, rmax를 외경으로 주면 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randompointinellipse&#34;&gt;G4RandomPointInEllipse&lt;/h3&gt;
&lt;p&gt;평면 타원 내에서 균일한 분포의 &lt;strong&gt;2차원 점&lt;/strong&gt;을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4TwoVector G4RandomPointInEllipse(G4double a, G4double b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ {x^2 \over a^2} +  {y^2 \over b^2} = 1 $의 타원의 방정식을 따르는 평면 타원에 대해 $a$, $b$를 입력인자로 넣으면, 타원 내에서 균일한 분포의 2차원 점을 샘플링하여 반환해줍니다. G4TwoVector는 2차원 벡터를 다루는 클래스로,  G4ThreeVector와 유사하게 사용하면 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randompointonellipse&#34;&gt;G4RandomPointOnEllipse&lt;/h3&gt;
&lt;p&gt;평면 타원의 &lt;strong&gt;원주 위&lt;/strong&gt;에서 균일한 분포의 &lt;strong&gt;2차원 점&lt;/strong&gt;을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4TwoVector G4RandomPointOnEllipse(G4double a, G4double b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ {x^2 \over a^2} +  {y^2 \over b^2} = 1 $의 타원의 방정식을 따르는 평면 타원에 대해 $a$, $b$를 입력인자로 넣으면, 타원의 원주 위에서 균일한 분포의 2차원 점을 샘플링하여 반환해줍니다. &lt;b&gt;In과 On의 차이에 주의하세요&lt;/b&gt;.&lt;/p&gt;
&lt;h3 id=&#34;g4randompointonellipsoid&#34;&gt;G4RandomPointOnEllipsoid&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3차원 타원체의 표면 위&lt;/strong&gt;에서 균일한 분포의 &lt;strong&gt;3차원 점&lt;/strong&gt;을 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;G4ThreeVector G4RandomPointOnEllipsoid(G4double a, G4double b, G4double c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ {x^2 \over a^2} +  {y^2 \over b^2} + {z^2 \over c^2} = 1 $의 타원체의 방정식을 따르는 3차원 타원체에 대해 $a$, $b$, $c$를 입력인자로 넣으면, 타원체의 겉표면 위에서 균일한 분포의 3차원 점을 샘플링하여 반환해줍니다.&lt;/p&gt;
&lt;h3 id=&#34;g4uniformrand&#34;&gt;G4UniformRand&lt;/h3&gt;
&lt;p&gt;$ X \sim \mathcal{U}(0,1) $를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double G4UniformRand();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;g4randflatshoot&#34;&gt;G4RandFlat::shoot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;균등분포&lt;/strong&gt;를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double shoot(double a, double b); // example: G4RandFlat::shoot(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ X \sim \mathcal{U}(a,b) $를 따르는 확률변수 $ X $를 샘플링하는 함수입니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randgaussqshoot&#34;&gt;G4RandGaussQ::shoot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;정규분포&lt;/strong&gt;를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double shoot(double mean, double stdDev); // example: G4RandGaussQ::shoot(mean, stdDev)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;평균(mean)이 $\mu$이고, 표준편차(stdDev)가 $\sigma$인 $ X \sim \mathcal{N}(\mu , {\sigma}^2) $를 따르는 확률변수 $ X $를 샘플링하는 함수입니다.&lt;/p&gt;
&lt;h3 id=&#34;g4randexponentialshoot&#34;&gt;G4RandExponential::shoot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;지수분포&lt;/strong&gt;를 따르는 &lt;strong&gt;실수&lt;/strong&gt;를 샘플링하는 함수입니다. 원형은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double shoot(double mean); // example: G4RandExponential::shoot(mean)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;평균(mean)이 $\lambda$인 $ X \sim Exp(\lambda) $를 따르는 확률변수 $ X $를 샘플링하는 함수입니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;실제-적용---등방성-점선원&#34;&gt;실제 적용 - 등방성 점선원&lt;/h2&gt;
&lt;p&gt;이제 맨처음 고민하였던 등방성 점선원을 모사하는 방법을 모두 알아냈습니다.&lt;/p&gt;
&lt;p&gt;PrimaryGeneratorAction 코드를 다음과 같이 작성하면 등방성 점선원을 모사할 수 있게 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;헤더 &lt;b&gt;G4RandomTools.hh&lt;/b&gt;를 포함&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SetParticleMomentumDirection() 함수의 입력 인자&lt;/strong&gt;로, &lt;strong&gt;G4RandomDirection() 함수의 출력값&lt;/strong&gt;을 대입&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;실제 소스코드는 다음과 같이 작성하면 됩니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;03_isotropic_code&#34; srcset=&#34;
               /g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_06f7655ae73400be0b340c2d8c09eaa6.png 400w,
               /g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_73906b086d23b6828dd99db790e906a2.png 760w,
               /g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/g4-noqasked-009-randtool/03_isotropic_code_huf9814039e9a694a5d2c0466fbee79250_31171_06f7655ae73400be0b340c2d8c09eaa6.png&#34;
               width=&#34;650&#34;
               height=&#34;641&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;최종-파일-다운받는-법&#34;&gt;최종 파일 다운받는 법&lt;/h2&gt;
&lt;p&gt;이번 글에서 작성한 코드는 &lt;a href=&#34;https://github.com/evandde/g4_minimal/archive/a15e944fa685c9f8e11dcfa1849826fe3d959194.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;이 링크&lt;/a&gt;를 통해 다운받을 수 있습니다.&lt;/p&gt;
&lt;p&gt;혹은 git repository를 clone하신 분의 경우에는, example branch의 이전 커밋 중 V2 PriGen이라는 커밋을 참고하셔도 됩니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;정리&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;이로써 선원항을 정의하는 방법까지 마쳤습니다.&lt;/p&gt;
&lt;p&gt;다음 글에서는 시뮬레이션을 돌리며 원하는 정보를 획득하는 &lt;strong&gt;스코어링&lt;/strong&gt;에 대해 살펴보도록 하겠습니다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;사실 컴퓨터는 완전히 무작위적인 난수를 발생시키지는 못해서 의사난수(pseudo random number)를 샘플링하는 함수들을 제공합니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;이상적인 난반사 표면에서 방출되는 선속이 법선벡터로부터 벗어난 각도의 $ \mathcal{cos} $ 값에 비례한다는 법칙. 참고 링크: &lt;a href=&#34;https://en.wikipedia.org/wiki/Lambert%27s_cosine_law&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lambert&amp;rsquo;s cosine law - Wikipedia&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
  </channel>
</rss>
