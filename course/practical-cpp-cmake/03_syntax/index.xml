<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>기초 문법 | EvaNote</title>
    <link>https://evandde.github.io/course/practical-cpp-cmake/03_syntax/</link>
      <atom:link href="https://evandde.github.io/course/practical-cpp-cmake/03_syntax/index.xml" rel="self" type="application/rss+xml" />
    <description>기초 문법</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>ko-kr</language><copyright>© 2020–2022 Evan Kim</copyright><lastBuildDate>Thu, 30 Dec 2021 10:25:00 +0900</lastBuildDate>
    <image>
      <url>https://evandde.github.io/media/icon_hu8e7e87b14a52eedd9109bf1b224bd29e_18847_512x512_fill_lanczos_center_3.png</url>
      <title>기초 문법</title>
      <link>https://evandde.github.io/course/practical-cpp-cmake/03_syntax/</link>
    </image>
    
    <item>
      <title>대충보는 C&#43;&#43; &amp; CMake - 7. 주석(comment)</title>
      <link>https://evandde.github.io/praccpp-007-comment/</link>
      <pubDate>Fri, 07 Jan 2022 16:23:33 +0900</pubDate>
      <guid>https://evandde.github.io/praccpp-007-comment/</guid>
      <description>&lt;p&gt;이 글에서는 C++ 코드에서의 주석에 대해 알아봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;주석(Comment)이란 사람만 볼 수 있게끔 적는 메모&lt;/li&gt;
&lt;li&gt;한 줄짜리 주석은 &lt;code&gt;//&lt;/code&gt; 표시를 이용. &lt;code&gt;//&lt;/code&gt; 표시 이후 그 줄이 끝날 때까지의 내용이 주석처리되는 식. 예를 들면, &lt;code&gt;// 주석으로 적을 내용&lt;/code&gt;의 형태로 작성&lt;/li&gt;
&lt;li&gt;여러 줄짜리 주석은 &lt;code&gt;/*&lt;/code&gt;과 &lt;code&gt;*/&lt;/code&gt; 표시를 이용. &lt;code&gt;/*&lt;/code&gt; 표시 이후부터 &lt;code&gt;*/&lt;/code&gt; 표시 이전까지의 내용이 주석처리되는 식. 예를 들면, &lt;code&gt;/* 주석으로 적을 내용 */&lt;/code&gt;의 형태로 작성&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;주석comment&#34;&gt;주석(Comment)&lt;/h2&gt;
&lt;p&gt;주석이란 &lt;strong&gt;사람이 C++ 코드를 이해하기 쉽도록 돕기 위해 적어놓는 설명&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;C++ 코드를 보자마자 코드의 구조, 내용, 원리가 한 눈에 들어오는 능력자도 있겠지만, 저처럼 코드를 한참 들여다봐야 간신히 그 내용이 이해가 되는 불쌍한 중생도 있겠지요. 만약 코드에 대한 설명을 사람의 언어(한국어든 영어든)로 풀어서 메모해 둔다면, 누가 그 코드를 보더라도 그 코드가 무슨 역할을 하기 위해 작성된 것인지 금방 이해할 수 있을 것입니다.&lt;/p&gt;
&lt;p&gt;이런 메모는 C++ 언어가 아니라 사람의 언어로 적을 것이므로, 컴파일러가 이 메모를 무시하도록 해 주어야합니다. 그렇지 않으면 &amp;quot;이 내용은 C++ 문법에 맞지 않습니다&amp;quot;라며 에러를 띄울 것이기 때문이죠.&lt;/p&gt;
&lt;p&gt;이렇게 컴파일러는 내용을 무시하고 넘어가게끔 하되 &lt;strong&gt;사람만 알아볼 수 있도록 적어두는 메모&lt;/strong&gt;를 &lt;strong&gt;주석&lt;/strong&gt;이라고 합니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;간혹, 한글로 주석을 적을 경우 유니코드 관련 문제로 인해 오류가 발생하거나 폰트가 깨지는 등의 문제가 발생할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;이 글에서는 이해를 돕고자 한글 주석을 사용하지만, 이후에는 되도록 영어 주석으로 진행할 예정입니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;한-줄짜리-주석&#34;&gt;한 줄짜리 주석(&lt;code&gt;//&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;한 줄짜리 주석은 &lt;code&gt;//&lt;/code&gt; 표시를 이용하여 작성합니다. 줄의 어느 위치에서든 쓸 수 있으며, &lt;code&gt;//&lt;/code&gt; 표시 이후로 그 줄이 끝날 때(줄바꿈)까지의 모든 내용이 주석처리됩니다. 예를 들어 코드로 보면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

int main(int, char**) {
    // 이 부분은 주석입니다.
    // 다음 줄은 화면에 Hello, world!라는 문구를 표시하는 코드입니다.
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello, world!\n&amp;quot;; // 이렇게 코드에 이어서 쓸 수도 있습니다.
}

// main 함수 바깥에도 쓸 수 있습니다.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;01_linecomment&#34; srcset=&#34;
               /praccpp-007-comment/01_linecomment_hu0dae6e31c7be37e1bd58b130fff5cb0f_17491_710e1e859819b5680fe86bf7766fc58f.png 400w,
               /praccpp-007-comment/01_linecomment_hu0dae6e31c7be37e1bd58b130fff5cb0f_17491_36a5465a5f08e0586a47e3884a960932.png 760w,
               /praccpp-007-comment/01_linecomment_hu0dae6e31c7be37e1bd58b130fff5cb0f_17491_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/praccpp-007-comment/01_linecomment_hu0dae6e31c7be37e1bd58b130fff5cb0f_17491_710e1e859819b5680fe86bf7766fc58f.png&#34;
               width=&#34;744&#34;
               height=&#34;271&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;이와 같이 작성하고 실행해보시면, 이전과 완전히 동일한 결과를 얻을 것입니다.
컴파일러는 주석을 무시하기 때문에 코드 내용 상 변화가 없는 것이나 마찬가지이기 때문입니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;03_runresult&#34; srcset=&#34;
               /praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_e0ea3814e5e5bba50823e3efef8d029d.png 400w,
               /praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_a036bfc9d6e36b6e528ef8706fd8eb5e.png 760w,
               /praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_e0ea3814e5e5bba50823e3efef8d029d.png&#34;
               width=&#34;601&#34;
               height=&#34;207&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;여러-줄짜리-주석-&#34;&gt;여러 줄짜리 주석(&lt;code&gt;/*&lt;/code&gt;, &lt;code&gt;*/&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;여러 줄짜리 주석은 &lt;code&gt;/*&lt;/code&gt; 표시로 시작하여 &lt;code&gt;*/&lt;/code&gt; 표시로 끝나는 형태로 작성합니다. &lt;code&gt;/*&lt;/code&gt;와 &lt;code&gt;*/&lt;/code&gt; 표시는 어느 위치에서든 쓸 수 있으며, 그 사이의 모든 내용이 주석처리됩니다. 예를 들어 코드로 보면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

/* 이 부분은 주석처리 되는 부분입니다.
이렇게 줄바꿈을 해도 여전히 주석입니다.
계속 주석처리 되고 있는 중입니다.
...
이제 주석을 끝내보겠습니다. */

int main(int, char**) {
    /* 이렇게 한 줄만 주석처리해도 됩니다.*/
    std::cout &amp;lt;&amp;lt; &amp;quot;Hello, world!\n&amp;quot;;
    /*
    여러 줄로 
    길게 설명을 
    해야 할 때에 
    활용해보세요
    */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;02_multilinecomment&#34; srcset=&#34;
               /praccpp-007-comment/02_multilinecomment_hua4ceae26b126b6f82fe045fd7f397d2f_14699_7fab626627f22095aeb132322df6851c.png 400w,
               /praccpp-007-comment/02_multilinecomment_hua4ceae26b126b6f82fe045fd7f397d2f_14699_9d331d04c1015dbd4586a113e0c72681.png 760w,
               /praccpp-007-comment/02_multilinecomment_hua4ceae26b126b6f82fe045fd7f397d2f_14699_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/praccpp-007-comment/02_multilinecomment_hua4ceae26b126b6f82fe045fd7f397d2f_14699_7fab626627f22095aeb132322df6851c.png&#34;
               width=&#34;462&#34;
               height=&#34;479&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;마찬가지로, 실행해보시면 동일한 결과를 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;03_runresult&#34; srcset=&#34;
               /praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_e0ea3814e5e5bba50823e3efef8d029d.png 400w,
               /praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_a036bfc9d6e36b6e528ef8706fd8eb5e.png 760w,
               /praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://evandde.github.io/praccpp-007-comment/03_runresult_hud82ddfc522d9f9665387429ccfb8dde0_8358_e0ea3814e5e5bba50823e3efef8d029d.png&#34;
               width=&#34;601&#34;
               height=&#34;207&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;changelog&#34;&gt;Changelog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2022-01-07: 최초 게시&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>대충보는 C&#43;&#43; &amp; CMake - 8. 자료형(type)</title>
      <link>https://evandde.github.io/praccpp-008-type/</link>
      <pubDate>Thu, 30 Dec 2021 10:28:53 +0900</pubDate>
      <guid>https://evandde.github.io/praccpp-008-type/</guid>
      <description>&lt;p&gt;이 글에서는 C++의 근간이 되는 개념인 &lt;strong&gt;자료형&lt;/strong&gt;에 대해 알아봅니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++은 자료형 기반의 언어임. C++에서 사용되는 모든 데이터는 어떤 자료형인지 명확하게 정해져 있어야만 함&lt;/li&gt;
&lt;li&gt;대표적인 기본 자료형 &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;std::string&lt;/code&gt;  정도는 기억할 것&lt;/li&gt;
&lt;li&gt;대부분의 경우, 숫자 형태의 데이터는 &lt;code&gt;int&lt;/code&gt;나 &lt;code&gt;double&lt;/code&gt;로, 문자 형태의 데이터는 &lt;code&gt;&amp;quot;&lt;/code&gt;(큰따옴표)로 묶어서 &lt;code&gt;std::string&lt;/code&gt; 자료형으로 다룸&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;자료형&#34;&gt;자료형&lt;/h2&gt;
&lt;p&gt;C++에서 &lt;b&gt;자료형(type)&lt;/b&gt;이라는 개념은 매우 중요합니다. C++ 언어로 짜여진 코드를 컴파일 하기 위해서는, 코드 내의 모든 변수, 함수의 입력인자, 함수의 출력인자의 자료형이 정해져 있어야만 합니다.&lt;/p&gt;
&lt;p&gt;자료형이란 말그대로 데이터가 어떤 종류의 자료인지를 설명하는 것입니다. 예를 들어 &lt;code&gt;3&lt;/code&gt;은 &lt;strong&gt;정수&lt;/strong&gt;라는 종류로, &lt;code&gt;-1.8&lt;/code&gt;은 &lt;strong&gt;실수&lt;/strong&gt;라는 종류로, &lt;code&gt;&#39;c&#39;&lt;/code&gt;는 &lt;strong&gt;문자&lt;/strong&gt;라는 종류로 분류해볼 수 있겠네요. 이렇게 분류에 사용한 개념인 &lt;b&gt;정수, 실수, 문자&lt;/b&gt;같은 것을 자료형이라고 합니다.&lt;/p&gt;
&lt;p&gt;C++에는 언어 자체적으로 제공하는 몇 가지의 기본자료형(built-in type)이 있어, 간단한 데이터에 대해서는 이 기본자료형으로 자료형을 정해줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;만약 기본자료형으로 부족함을 느끼신다면, 여러분이 직접 자료형을 만들어서 사용할 수도 있습니다. 이를 클래스(class)라고 합니다. 이에 대해서는 나중에 다루겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;기본자료형&#34;&gt;기본자료형&lt;/h2&gt;
&lt;p&gt;기본자료형에도 많은 종류가 있습니다. 예를 들면 정수를 저장하더라도, 크기가 작은 정수를 저장할 때에는 메모리 공간을 조금만 써도 되니 일종의 &lt;b&gt;작은 정수&lt;/b&gt;라는 자료형도 있고, 크기가 큰 정수를 저장해야 할 때에는 &lt;b&gt;큰 정수&lt;/b&gt;라는 자료형에 저장하는 식입니다.&lt;/p&gt;
&lt;p&gt;하지만 이 시리즈에서는 그렇게 세세하게 다 살펴보지는 않을 것입니다. 그냥 대중적으로 쓰이는 &lt;b&gt;기본자료형 5가지만 기억&lt;/b&gt;하고 가겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;bool&#34;&gt;bool&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bool&lt;/code&gt;은 &lt;b&gt;참(true)&lt;/b&gt;과 &lt;b&gt;거짓(false)&lt;/b&gt;이라는 두 가지 데이터를 담당하는 자료형입니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;b&gt;&amp;quot;3은 5보다 작다&amp;quot;&lt;/b&gt;라는 내용이 있다면, 우리는 이것을 보고 참(true)이라고 생각할 것입니다. 그렇다면 &lt;b&gt;&amp;quot;3은 5보다 작다&amp;quot;&lt;/b&gt;라는 내용은 &lt;code&gt;bool&lt;/code&gt; 자료형의 데이터라고 볼 수 있는 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;int&#34;&gt;int&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int&lt;/code&gt;는 &lt;strong&gt;정수&lt;/strong&gt;를 담당하는 자료형입니다. &lt;code&gt;-153&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;22&lt;/code&gt;, &amp;hellip; 등 소수점 이하를 가지지 않는 정수를 C++에서는 &lt;code&gt;int&lt;/code&gt; 자료형으로 구분합니다.&lt;/p&gt;
&lt;h3 id=&#34;double&#34;&gt;double&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt;은 &lt;strong&gt;실수&lt;/strong&gt;를 담당하는 자료형입니다. &lt;code&gt;-3.2&lt;/code&gt;, &lt;code&gt;0.72351&lt;/code&gt;, &amp;hellip; 등 소수점 이하를 가지는 실수를 C++에서는 &lt;code&gt;double&lt;/code&gt; 자료형으로 구분합니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;수학적으로는 정수 값이라고 여겨지더라도, C++에서는 소수점 이하를 가진다면 &lt;code&gt;int&lt;/code&gt;가 아니라 &lt;code&gt;double&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;3&lt;/code&gt;은 &lt;code&gt;int&lt;/code&gt; 자료형이지만, &lt;code&gt;3.0&lt;/code&gt;은 &lt;code&gt;double&lt;/code&gt; 자료형입니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;char&#34;&gt;char&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;는 한 글자의 문자를 담당하는 자료형입니다. &lt;code&gt;&#39;&lt;/code&gt;(작은따옴표) 표시로 감싸진 한 글자의 문자만 이에 해당합니다.&lt;/p&gt;
&lt;p&gt;예를 들면, &lt;code&gt;&#39;a&#39;&lt;/code&gt;, &lt;code&gt;&#39;T&#39;&lt;/code&gt;, &lt;code&gt;&#39;1&#39;&lt;/code&gt;, &lt;code&gt;&#39;.&#39;&lt;/code&gt;, &amp;hellip; 등과 같은 데이터가 &lt;code&gt;char&lt;/code&gt; 자료형입니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;code&gt;1&lt;/code&gt;과 &lt;code&gt;1.0&lt;/code&gt;과 &lt;code&gt;&#39;1&#39;&lt;/code&gt;은 C++ 입장에서 전혀 다른 데이터입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt;은 정수 1로서, &lt;code&gt;int&lt;/code&gt; 자료형입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.0&lt;/code&gt;은 실수 1.0으로서, &lt;code&gt;double&lt;/code&gt; 자료형입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&#39;1&#39;&lt;/code&gt;은 1이라는 모양을 가진 글자 한 개로서, &lt;code&gt;char&lt;/code&gt; 자료형입니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;stdstring&#34;&gt;std::string&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;은 문자들로 구성된 글 데이터를 담당하는 자료형입니다. &lt;code&gt;&amp;quot;&lt;/code&gt;(큰따옴표) 표시로 감싸진 문자들을 말합니다. 이를 프로그래밍에서는 &lt;strong&gt;문자열&lt;/strong&gt;이라고 부릅니다.&lt;/p&gt;
&lt;p&gt;예를 들면, &lt;code&gt;&amp;quot;ABC&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;Hi.&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;Hello, world!&amp;quot;&lt;/code&gt;, &amp;hellip; 등과 같은 데이터가 &lt;code&gt;std::string&lt;/code&gt; 자료형입니다.&lt;/p&gt;
&lt;p&gt;최근의 C++에서 글자로 구성된 데이터를 다룰 때에는 대부분 &lt;code&gt;std::string&lt;/code&gt;을 쓰는 추세입니다. 심지어 한 글자의 문자를 저장할 때에도, &lt;code&gt;char&lt;/code&gt;보다는 &lt;code&gt;std::string&lt;/code&gt; 자료형을 사용하지요.
&lt;code&gt;char&lt;/code&gt;이라는 자료형은 &lt;b&gt;이 데이터는 무조건 한 글자의 문자&lt;/b&gt;라는 것이 명확한 경우에 사용될 뿐, 대부분 문자 형태의 데이터를 다룰 때에는 &lt;code&gt;std::string&lt;/code&gt; 자료형을 쓴다고 보시면 됩니다.&lt;/p&gt;
&lt;p&gt;다만, 최적화의 목적등을 위해 사용하는 경우도 있고, 혹은 이전부터 사용하던 함수에서 &lt;code&gt;char&lt;/code&gt;을 보게 될 일도 꽤 많으므로, 둘 다 기억해두시기 바랍니다.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;C++에서는 &lt;code&gt;&#39;&lt;/code&gt;(작은따옴표)로 감싼 문자와 &lt;code&gt;&amp;quot;&lt;/code&gt;(큰따옴표)로 감싼 문자는 완전히 다릅니다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;&#39;a&#39;&lt;/code&gt;은 &lt;code&gt;char&lt;/code&gt; 자료형이지만, &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;은 &lt;code&gt;std::string&lt;/code&gt; 자료형입니다.&lt;/p&gt;
&lt;p&gt;또한, &lt;code&gt;&amp;quot;&lt;/code&gt;로는 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;와 같이 여러 개의 문자들을 한 번에 묶어서 감쌀 수 있지만, &lt;code&gt;&#39;&lt;/code&gt;로는 &lt;code&gt;&#39;abc&#39;&lt;/code&gt;와 같이 사용하실 수 없으며 무조건 한 개의 문자만 감싸는 형태로 사용하셔야 합니다.&lt;/p&gt;

  &lt;/div&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;chanagelog&#34;&gt;Chanagelog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2021-12-30: 최초 게시&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;code&gt;std::cout&lt;/code&gt;때와 유사하게, 엄밀히 말하자면 &lt;code&gt;std::string&lt;/code&gt;이라는 표현은 &lt;code&gt;std&lt;/code&gt;에 소속된 &lt;code&gt;string&lt;/code&gt;이라는 자료형의 의미입니다. 다만 여기서는 &lt;code&gt;std::string&lt;/code&gt;이라는 것을 통째로 기억하시길 권해드립니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
    <item>
      <title>대충보는 C&#43;&#43; &amp; CMake - 9. 변수와 auto</title>
      <link>https://evandde.github.io/praccpp-009-variable/</link>
      <pubDate>Sat, 19 Mar 2022 20:22:14 +0900</pubDate>
      <guid>https://evandde.github.io/praccpp-009-variable/</guid>
      <description>&lt;p&gt;이 글에서는 C++에서 &lt;strong&gt;변수를 선언하는 법&lt;/strong&gt;과 &lt;strong&gt;그 변수에 값을 저장&lt;/strong&gt;하는 법을 알아봅니다.&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++에서는 문장을 쓰고 마침표의 의미로 세미콜론(&lt;code&gt;;&lt;/code&gt;)을 씀&lt;/li&gt;
&lt;li&gt;&lt;code&gt;자료형 변수명;&lt;/code&gt; (e.g. &lt;code&gt;int num;&lt;/code&gt;) 이라고 작성하여 메모리 공간 중 일부에 &lt;code&gt;변수명&lt;/code&gt;이라는 이름을 붙여 활용할 수 있으며, &lt;code&gt;=&lt;/code&gt; 연산자를 활용하여 그 공간에 값을 저장할 수도 있음&lt;/li&gt;
&lt;li&gt;자료형을 적어야 할 때 &lt;strong&gt;그 데이터의 자료형을 컴파일러가 결정할 수 있는 상태&lt;/strong&gt;라면 자료형을 굳이 직접 쓰지 않아도 &lt;code&gt;auto&lt;/code&gt;라는 키워드를 통해 컴파일러에게 자료형 결정을 떠넘길 수 있음 (e.g. &lt;code&gt;auto num = 3;&lt;/code&gt;이라고 쓰면 컴파일러가 &lt;code&gt;auto&lt;/code&gt; 부분을 알아서 &lt;code&gt;int&lt;/code&gt;로 인식함)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;세미콜론&#34;&gt;세미콜론(&lt;code&gt;;&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;우리말은 문장이 끝났다는 의미로 마침표(&#39;.&#39;)를 적습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++에서도 컴파일러에게 한 문장이 끝났다는 것을 명시&lt;/strong&gt;해주어야 합니다. 이 때 마침표의 의미로 사용하는 기호가 &lt;b&gt;세미콜론(&lt;code&gt;;&lt;/code&gt;)&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p&gt;너무나 당연하게 자주 사용하고 보게 될 기호입니다만, 따로 강의글까지 만들 정도의 내용은 아닌 것 같아, 여기서 간단하게 설명하고 넘어갑니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;변수&#34;&gt;변수&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;변수&lt;/strong&gt;란 간단히 말해 &lt;strong&gt;자유로운 데이터 저장소&lt;/strong&gt;입니다. 제한조건은 단 한 가지, &lt;strong&gt;미리 그 저장소의 자료형을 정해두어야 한다는 것&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h3 id=&#34;변수의-선언declaration&#34;&gt;변수의 선언(declaration)&lt;/h3&gt;
&lt;p&gt;변수의 선언이란, C++ 프로그램에서 &lt;strong&gt;이 변수를 사용하겠다&lt;/strong&gt;라고 선언하는 것을 뜻합니다. 코드로는 &lt;code&gt;자료형 변수명;&lt;/code&gt;과 같이 적습니다.&lt;/p&gt;
&lt;p&gt;변수명으로는 알파벳 대소문자(&lt;code&gt;A~Z&lt;/code&gt;, &lt;code&gt;a~z&lt;/code&gt;), 숫자(&lt;code&gt;0~9&lt;/code&gt;), 언더바(&lt;code&gt;_&lt;/code&gt;)를 자유롭게 조합하여 사용할 수 있습니다. (일부 C++에서 사용하는 문구는 불가능한 경우도 있습니다.)&lt;/p&gt;
&lt;p&gt;예시를 보자면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int num; // Declare an int-type variable named &amp;quot;num&amp;quot;
double dbl_val; // Declare a double-type variable named &amp;quot;dbl_val&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;값의-저장과-사용&#34;&gt;값의 저장과 사용&lt;/h3&gt;
&lt;p&gt;변수를 만들어두었다면, 이 변수에 임의의 값을 저장해 둘 수 있습니다. 저장할 때에는 &lt;code&gt;변수명 = 저장할값;&lt;/code&gt;과 같이 적습니다. &lt;code&gt;=&lt;/code&gt; 기호는 같다는 의미의 연산자가 아니라 &lt;b&gt;우측의 값을 좌측의 메모리공간에 대입하는 연산자&lt;/b&gt;입니다.&lt;/p&gt;
&lt;p&gt;만약, 변수를 선언함과 동시에 값의 저장까지 하고 싶다면, &lt;code&gt;자료형 변수명 = 저장할값;&lt;/code&gt;과 같이 한 데 묶어서 적을 수도 있습니다&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;이 때, &lt;font color=red&gt;&lt;b&gt;변수의 자료형과 저장할 값의 자료형은 동일해야 합니다&lt;/b&gt;&lt;/font&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;값이 저장되어 있다면, 이후에는 &lt;code&gt;변수명&lt;/code&gt;을 이용하여 그 값이 필요한 곳에서 자유롭게 호출하여 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;저장된 값을 변경하려면 &lt;code&gt;변수명 = 저장할값;&lt;/code&gt;을 한 번 더 쓰면 됩니다.&lt;/p&gt;
&lt;p&gt;예시를 보자면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int num = 3; // The value &amp;quot;3&amp;quot; was stored in a variable named &amp;quot;num&amp;quot;
std::cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl; // This will print 3
num = 5; // The value of variable named &amp;quot;num&amp;quot; has been changed to &amp;quot;5&amp;quot;
std::cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; std::endl; // This will print 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;auto-키워드&#34;&gt;auto 키워드&lt;/h2&gt;
&lt;p&gt;자료형을 적어야 할 때, &lt;b&gt;그 자리에 무슨 자료형이 적혀야 하는지가 명확하다면&lt;/b&gt;, 자료형을 직접 적지않고 컴파일러가 알아서 결정하게끔 할 수 있습니다. 이 때 활용하는 키워드가 &lt;code&gt;auto&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code&gt;int num = -1;&lt;/code&gt; 이라는 문장을 생각해봅시다. 여기서 &lt;code&gt;int&lt;/code&gt; 자리에 굳이 &lt;code&gt;int&lt;/code&gt;라는 자료형을 명시해주지 않더라도, &lt;code&gt;num&lt;/code&gt;이라는 변수가 &lt;code&gt;-1&lt;/code&gt;이라는 값을 저장해야 한다는 사실로부터 &lt;code&gt;num&lt;/code&gt;의 자료형이 &lt;code&gt;int&lt;/code&gt;가 되어야 한다고 판단할 수 있겠지요&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. 이런 경우에는 &lt;code&gt;int&lt;/code&gt; 대신 &lt;code&gt;auto&lt;/code&gt;를 적을 수 있습니다. 다음과 같이 말이지요.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto num = -1; // int num = -1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;단, 컴파일러가 자료형을 결정할 수 없는 경우에는 &lt;code&gt;auto&lt;/code&gt; 키워드를 사용할 수 없습니다. 예를 들어 &lt;code&gt;auto num;&lt;/code&gt;과 같이 값을 저장하지 않고 선언만 하는 경우에는, &lt;code&gt;num&lt;/code&gt;이 어떤 자료형을 가져야 하는지 판단할 수 없으므로 &lt;font color=red&gt;컴파일 에러가 발생&lt;/font&gt;합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chanagelog&#34;&gt;Chanagelog&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2022-03-19: 최초 게시&lt;/li&gt;
&lt;/ul&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;좀 더 정교한 설명을 위해서는, 선언(declare)/정의(define)/초기화(initialize)/할당(assign) 등으로 용어를 좀 더 세분화하여 이해할 필요도 있겠으나, 여기서는 간단하게만 설명하고 넘어가겠습니다. 필요한 분은 위의 키워드를 검색하여 공부해보시기 바랍니다.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;엄밀히 말하면 동일하지는 않아도 됩니다만, 저장할 값의 자료형으로부터 변수의 자료형으로 자동 형변환이 이루어질 수 있어야 합니다. 예를 들어, 3.0이라는 실수 자료형은 C++에서 자동적으로 3이라는 정수 자료형으로 형변환이 가능합니다. 이 경우에는 &lt;code&gt;int num = 3.0;&lt;/code&gt;과 같이 적어도 에러가 발생하지는 않습니다(warning은 발생할 수도 있습니다).&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;경우에 따라 가능한 자료형이 여러 가지인 경우도 있습니다. 이런 경우에는 &lt;code&gt;auto&lt;/code&gt; 키워드를 어떤 자료형으로 인식할 것인지 컴파일러가 가진 나름의 규칙을 바탕으로 결정합니다.&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    
  </channel>
</rss>
